<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Castie! Notes</title>
  <meta name="description" content="  在上周, 我们已经通过Ps将Lifestyle页面给设计出来了, 本周我们就可以按照设计图纸进行开工啦, 今天我们就按部就班的完成LifestyleViewController的第一个功能无限轮播图!!">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="iOS 投机流实现 无限轮播图">
  <meta name="twitter:description" content="  在上周, 我们已经通过Ps将Lifestyle页面给设计出来了, 本周我们就可以按照设计图纸进行开工啦, 今天我们就按部就班的完成LifestyleViewController的第一个功能无限轮播图!!">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="iOS 投机流实现 无限轮播图">
  <meta property="og:description" content="  在上周, 我们已经通过Ps将Lifestyle页面给设计出来了, 本周我们就可以按照设计图纸进行开工啦, 今天我们就按部就班的完成LifestyleViewController的第一个功能无限轮播图!!">
  
  <link rel="icon" type="image/ico" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/ico">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2016/06/iOS-%E6%8A%95%E6%9C%BA%E6%B5%81%E5%AE%9E%E7%8E%B0-%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%9B%BE/">
  <link rel="alternate" type="application/rss+xml" title="Castie!" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Castie! 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Castie! logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Castie!" class="blog-button">Castie!</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">正态分布, 优劣伴生</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">北冥有鱼，其名为鲲（kūn）。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description">北海若曰：“井鼃不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。今尔出于崖涘，观于大海，乃知尔丑，尔将可与语大理矣。</p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="https://coderzsq.github.io/coderZsq.practice.web//" target="_blank" title="我的简历">简历</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
    <!-- juejin-->
    <li class="navigation__item">
      <a href="https://juejin.im/user/57e735dfa22b9d00614eecb8/posts" title="@coderZsq 的稀土掘金" target="_blank">
        <i class='social fa fa-book'></i>
        <span class="label">juejin</span>
      </a>
    </li>
    

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/coderZsq" title="@coderZsq 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  

  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:a13701777868@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-disabled"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-06-10 13:22:00 +0800" itemprop="datePublished" class="post-meta__date date">2016-06-10</time> &#8226; <span class="post-meta__tags tags">移动开发</span>
    </div>
    <h1 class="post-title">iOS 投机流实现 无限轮播图</h1>
  </header>

  <section class="post">
    <blockquote>
  <p>在上周, 我们已经通过Ps将Lifestyle页面给设计出来了, 本周我们就可以按照设计图纸进行开工啦, 今天我们就按部就班的完成LifestyleViewController的第一个功能无限轮播图!!</p>
</blockquote>

<h6 id="参考链接">参考链接:</h6>

<ul>
  <li><a href="http://www.jianshu.com/p/a3e1b54c73d6">iOS 做好开工前的准备</a></li>
  <li><a href="http://www.jianshu.com/p/861c9c916b2a">iOS 集成Reveal UI调试利器</a></li>
  <li><a href="http://www.jianshu.com/p/440bdc425c02">UI/UX 产品原型 从Axure开始</a></li>
  <li><a href="http://www.jianshu.com/p/56eb4917f956">UI/UX 使用Ps 进行视觉设计</a></li>
</ul>

<p>以下内容在上述文章基础上进行, 请事先查阅.</p>

<p>无限轮播图, 这种简单的功能没什么技术含量, 实现的方式也各种各样, 技术含量较高的分为: 
1) UIScrollView<code class="highlighter-rouge">二图流</code>(就是两张图之间来回切换) 这个对算法的要求比较高, 一般不推荐自己写, 使用网上现成封装好的就好啦. 
2) UICollectionViewLayout<code class="highlighter-rouge">布局流</code>(使用自定义Layout布局) 这种对算法要求极高, 不过一劳永逸, 使用方便快捷低耦合.</p>

<p>还有其他的实现的方法我也不一一列举, 在SQExtension中也有封装好的SQInfiniteCell可以使用, 今天我推荐的方法是<code class="highlighter-rouge">投机流</code> 那什么是投机流呢, 且听我娓娓道来. 先回到我们的项目, 经过设计图分析,首先我们先将导航栏进行隐藏, 隐藏的方式各种各样, 可以直接<code class="highlighter-rouge">setHidden</code>但是为了我们之后的功能, 先按如下设置:</p>

<h5 id="隐藏导航栏">隐藏导航栏</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)loadView {
    [super loadView];
    [self.navigationItem setTitleView:[UIView new]];
    [self.navigationController.navigationBar setBackgroundImage:[UIImage imageWithColor:[UIColor clearColor]] forBarMetrics:UIBarMetricsDefault];
    [self.navigationController.navigationBar setShadowImage:[UIImage imageWithColor:[UIColor clearColor]]];
}

</code></pre>
</div>

<p>隐藏导航栏 我选择的方式是将导航栏填充透明背景色而不是将其隐藏. <code class="highlighter-rouge">setTitleView</code>是因为之前的框架有KVO属性, 接下来我们将tableView向上偏移64</p>

<p><code class="highlighter-rouge">_tableView.contentInset = UIEdgeInsetsMake(-64, 0, 0, 0);</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (UITableView *)tableView {
    
    if (!_tableView) {
        _tableView = [UITableView new];
        _tableView.frame = self.view.bounds;
        _tableView.dataSource = self;
        _tableView.delegate = self;
        _tableView.contentInset = UIEdgeInsetsMake(-64, 0, 0, 0);
    }
    return _tableView;
}

</code></pre>
</div>
<p>这样我们几步简单的操作, 就将导航栏给隐藏了, 接下来我们需要自定义Cell.</p>

<h5 id="自定义cell">自定义cell</h5>

<p>自定义Cell 的方式也是各有不同, 写法也大不一样, xib, 代码流等等, 我是属于纯代码流的, 并不是说我不会用AutoLayout, 而是我觉得用xib写自定义控件的效率和可维护性 还是比较低下的, 但这是今后的趋势Apple的开发这种可见即可得的出发点就是让我们不用关心展示层, 而更加关心业务逻辑.</p>

<p>扯远了… 我们现在使用纯代码, 之前我有讲过代码库这个功能, 就不过多赘述, 我们使用代码库在.h文件和.m文件中添加:</p>

<h6 id="h">.h</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (instancetype)cellWithTableView:(UITableView *)tableView;

+ (CGFloat)cellHeight;

</code></pre>
</div>

<h6 id="m">.m</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (instancetype)cellWithTableView:(UITableView *)tableView {
    
    NSString * identifier = NSStringFromClass([&lt;#class#&gt; class]);
    &lt;#class#&gt; * cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    if (!cell) {
        cell = [[&lt;#class#&gt; alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
    }
    return cell;
}

- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        [self setupSubviews];
    }
    return self;
}

- (void)setupSubviews {
    
}

- (void)layoutSubviews {
    [super layoutSubviews];
    
}

+ (CGFloat)cellHeight {
	return &lt;#cellHeight#&gt;;
}
</code></pre>
</div>

<p>接着我们在tableView的<code class="highlighter-rouge">cellForRow</code>和<code class="highlighter-rouge">heightForRow</code>代理方法中添加:</p>

<h6 id="cellforrow">cellForRow</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

    SQBannerCell * cell = [SQBannerCell cellWithTableView:tableView];
    return cell;
}

</code></pre>
</div>

<h6 id="heightforrow">heightForRow</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    return [SQBannerCell cellHeight];
}

</code></pre>
</div>
<p>这样我们的自定义Cell就算完成了, 非常简单快捷吧, 接下来我们要实现轮播图的功能!</p>

<h5 id="实现无限滚动">实现无限滚动</h5>

<p>现在我们就来说说这个投机流是怎么一回事. 我们还是使用UICollectionView 因为这样就不用我们自己来做复用缓存池啦 <code class="highlighter-rouge">cell.contentView.layer.contents = (__bridge id)[UIImage imageNamed:@"banner"].CGImage;</code> 这个是layer的寄宿图属性, 不懂得同学可以Google一下. (我只是偷懒 ^ ^)</p>

<h6 id="创建collectionview">创建CollectionView</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (UICollectionViewFlowLayout *)flowLayout {
    
    if (!_flowLayout) {
        _flowLayout = [UICollectionViewFlowLayout new];
        _flowLayout.minimumInteritemSpacing = 0.0f;
        _flowLayout.minimumLineSpacing = 0.0f;
        _flowLayout.scrollDirection = UICollectionViewScrollDirectionHorizontal;
    }
    return _flowLayout;
}

- (UICollectionView *)collectionView {
    
    if (!_collectionView) {
        _collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:self.flowLayout];
        _collectionView.dataSource = self;
        _collectionView.delegate = self;
        _collectionView.pagingEnabled = YES;
        _collectionView.bounces = NO;
        _collectionView.showsHorizontalScrollIndicator = NO;
        [_collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"cell"];
    }
    return _collectionView;
}

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {

    UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"cell" forIndexPath:indexPath];
    cell.contentView.layer.contents = (__bridge id)[UIImage imageNamed:@"banner"].CGImage;
    return cell;
}
</code></pre>
</div>
<h6 id="布局collectionview">布局collectionView</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)layoutSubviews {
    [super layoutSubviews];
    
    self.flowLayout.itemSize = self.contentView.bounds.size;
    self.collectionView.frame = self.contentView.bounds;
}
</code></pre>
</div>
<p>到这一步我们collectionView算是完成 但怎么完成无线滚动呢? 说好的投机呢?</p>

<h6 id="投机流大揭秘">投机流大揭秘</h6>

<p>使用全局来替换宏 这样的性能会好一点</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static const NSInteger kMultiply = 500;
static const NSInteger kCounts = 5;
</code></pre>
</div>

<p>这算神马投机?? 表示看不懂啊有木有!! 不急接着往下看!!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section {
    return kCounts * kMultiply;
}
</code></pre>
</div>

<p>在layoutSubviews中添加如下代码</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)layoutSubviews {
    [super layoutSubviews];
    
    self.flowLayout.itemSize = self.contentView.bounds.size;
    self.collectionView.frame = self.contentView.bounds;
    [self.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:kCounts * kMultiply * 0.5f inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredHorizontally animated:NO];
}
</code></pre>
</div>

<p>这样我们就完成了无限轮播了, 不信你试试, 相信聪明的同学已经看懂了, 没错就是在collectionView创建完之后让他从中间开始走, <code class="highlighter-rouge">kCounts</code>代表你数据源有几条数据, <code class="highlighter-rouge">kMultiply</code>代表着你的乘积, 其实并不是真正的无限循环, 但效果已经达到了不是, 坏笑~~ (用户不可能一直翻翻翻,翻个500多下吧, 脑残除外) 接下来继续分析设计图, 发现在pageControl下面有一个浮雕层, 我们把这张图片给添加进来, (使用Ps切图工具 CMD + C)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (UIImageView *)reliefArcImageView {
    
    if (!_reliefArcImageView) {
        _reliefArcImageView = [UIImageView new];
        _reliefArcImageView.image = [UIImage imageNamed:@"RelliefArc"];
    }
    return _reliefArcImageView;
}

- (UIPageControl *)pageControl {
    
    if (!_pageControl) {
        _pageControl = [UIPageControl new];
        _pageControl.hidesForSinglePage = YES;
        _pageControl.defersCurrentPageDisplay = YES;
        _pageControl.numberOfPages = kCounts;
        _pageControl.pageIndicatorTintColor = KC05_dddddd;
        _pageControl.currentPageIndicatorTintColor = KC01_57c2de;
    }
    return _pageControl;
}

- (void)setupSubviews {
    [self.contentView addSubview:self.collectionView];
    [self.contentView addSubview:self.reliefArcImageView];
    [self.contentView addSubview:self.pageControl];
}

- (void)layoutSubviews {
    [super layoutSubviews];
    
    self.flowLayout.itemSize = self.contentView.bounds.size;
    self.collectionView.frame = self.contentView.bounds;
    [self.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:kCounts * kMultiply * 0.5f inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredHorizontally animated:NO];
    
    CGFloat reliefArcImageViewX = 0;
    CGFloat reliefArcImageViewH = kScaleLength(50);
    CGFloat reliefArcImageViewY = self.height - reliefArcImageViewH;
    CGFloat reliefArcImageViewW = self.width;
    self.reliefArcImageView.frame = CGRectMake(reliefArcImageViewX, reliefArcImageViewY, reliefArcImageViewW, reliefArcImageViewH);
    
    CGFloat pageControlX = 0;
    CGFloat pageControlH = 35;
    CGFloat pageControlY = self.collectionView.bounds.size.height - pageControlH;
    CGFloat pageControlW = self.collectionView.bounds.size.width;
    self.pageControl.frame = CGRectMake(pageControlX, pageControlY, pageControlW, pageControlH);
}
</code></pre>
</div>
<p>接着我们在<code class="highlighter-rouge">scrollViewDidScroll</code>代理方法中添加,至此无限轮播大功告成!!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    
    self.pageControl.currentPage = ((NSInteger)((scrollView.contentOffset.x + self.contentView.frame.size.width) / self.contentView.frame.size.width) - 1) % kCounts;
}

</code></pre>
</div>
<h5 id="添加定时器">添加定时器</h5>
<p>接下来我们要做的就是添加定时器的功能了, 让其自动的轮播! 其实非常之简单!!</p>

<h6 id="1-在初始化的时候添加定时器-self-setuptimer">1) 在初始化的时候添加定时器 <code class="highlighter-rouge">[self setupTimer]</code>;</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        [self setupTimer];
        [self setupSubviews];
    }
    return self;
}
</code></pre>
</div>

<h6 id="2-配置定时器功能">2) 配置定时器功能</h6>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
    [self.timer invalidate];
}

- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {
    [self setupTimer];
}

- (void)setupTimer {
    if ([self respondsToSelector:@selector(updateTimer)]) {
        self.timer = [NSTimer timerWithTimeInterval:5.0f target:self selector:@selector(updateTimer) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];
    }
}

- (void)updateTimer {
    [self.collectionView setContentOffset:CGPointMake(self.collectionView.contentOffset.x + self.contentView.frame.size.width, 0) animated:YES];
}

</code></pre>
</div>
<p>到这 我们今天的功能就全部结束了, 投机流是不是非常简单高效快捷呢 哈哈哈~~~</p>

<h5 id="在reveal中显示">在Reveal中显示</h5>
<p><img src="http://upload-images.jianshu.io/upload_images/1229762-16226a0dc47f7e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<h5 id="最终显示">最终显示</h5>
<p><img src="http://upload-images.jianshu.io/upload_images/1229762-48e1787fbb0a36b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>具体源码及SQExtension方法信息 请到<a href="https://github.com/coderZsq">github</a>上进行下载!</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/06/iOS-%E4%BC%9A%E8%B7%B3%E8%88%9E%E7%9A%84TabbarController/" title="link to iOS 会跳舞的TabbarController">iOS 会跳舞的TabbarController</a></h2>
       <p class="excerpt">  上周的 收到大家一致的好评和转载, 小弟心中感到很是欣慰, 所以今天再此决定分享一个干货给各位小伙伴们!!参考链接:  iOS 做好开工前的准备  iOS 集成Reveal UI调试利器  UI/UX 产品原型 从Axure开始  UI/UX 使用Ps 进行视觉设计  iOS 投机流实现 无限轮播图以下内容在上述文章基础上进行, 请事先查阅.具体是什么干货呢, 今天要分享的是会跳舞的TabbarController, 什么是会跳舞的TabbarController? 很简单,就是使用自...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-06-18 14:19:00 +0800" class="post-list__meta--date date">2016-06-18</time> &#8226; <span class="post-list__meta--tags tags">移动开发</span><a class="btn-border-small" href=/2016/06/iOS-%E4%BC%9A%E8%B7%B3%E8%88%9E%E7%9A%84TabbarController/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/06/UI-UX-%E4%BD%BF%E7%94%A8Ps-%E8%BF%9B%E8%A1%8C%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/" title="link to UI/UX 使用Ps 进行视觉设计">UI/UX 使用Ps 进行视觉设计</a></h2>
       <p class="excerpt">Tools Photoshop CS6上周我们已经将产品原型基本完成了, 本周我们就按照原型图绘制出设计图, 工具当然是大家最熟悉不过的PS(因为 不太会用Sketch) 作为一名开发者, 花个一周时间来学习入门一下PS还是很有必要的,  好了 话不多说, 进入到我们今天的工作中来.当我们拿到原型图的时候 需要分析原型图中的所有元素, 定下色彩标准和字体的标准. 当然, 不同的项目, 也需要根据不同的情况来制定标准. 由于整套原型图的内容较多, 所以今天就把首页来绘制出来.PS 中有很多的...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-06-04 17:54:00 +0800" class="post-list__meta--date date">2016-06-04</time> &#8226; <span class="post-list__meta--tags tags">UI设计</span><a class="btn-border-small" href=/2016/06/UI-UX-%E4%BD%BF%E7%94%A8Ps-%E8%BF%9B%E8%A1%8C%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2018-06-30 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="https://github.com/coderZsq">@Castie!</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
