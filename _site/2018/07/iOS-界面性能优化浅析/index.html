<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Castie! Notes</title>
  <meta name="description"
    content="  GitHub Repo：coderZsq.project.iosFollow: coderZsq · GitHubResume: https://coderzsq.github.io/coderZsq.practice.web/">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title"
    content="iOS 界面性能优化浅析">
  <meta name="twitter:description"
    content="  GitHub Repo：coderZsq.project.iosFollow: coderZsq · GitHubResume: https://coderzsq.github.io/coderZsq.practice.web/">

  <meta property="og:type" content="article">
  <meta property="og:title"
    content="iOS 界面性能优化浅析">
  <meta property="og:description"
    content="  GitHub Repo：coderZsq.project.iosFollow: coderZsq · GitHubResume: https://coderzsq.github.io/coderZsq.practice.web/">

  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2018/07/iOS-%E7%95%8C%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B5%85%E6%9E%90/">
  <link rel="alternate" type="application/rss+xml" title="Castie!"
    href="http://localhost:4000/feed.xml">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
</head>

  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Castie! 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Castie! logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Castie!" class="blog-button">Castie!</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">正态分布, 优劣伴生</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">北冥有鱼，其名为鲲（kūn）。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description">北海若曰：“井鼃不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。今尔出于崖涘，观于大海，乃知尔丑，尔将可与语大理矣。</p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="https://coderzsq.github.io/coderZsq.practice.web/" target="_blank" title="我的简历">简历</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
    <!-- juejin-->
    <li class="navigation__item">
      <a href="https://juejin.im/user/57e735dfa22b9d00614eecb8/posts" title="@coderZsq 的稀土掘金" target="_blank">
        <i class='social fa fa-book'></i>
        <span class="label">juejin</span>
      </a>
    </li>
    

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/coderZsq" title="@coderZsq 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  

  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:a13701777868@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-disabled"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-07-08 14:30:00 +0800" itemprop="datePublished" class="post-meta__date date">2018-07-08</time> &#8226; <span class="post-meta__tags tags">移动开发</span>
    </div>
    <h1 class="post-title">iOS 界面性能优化浅析</h1>
  </header>

  <section class="post">
    <blockquote>
  <p>GitHub Repo：<a href="https://github.com/coderZsq/coderZsq.project.ios">coderZsq.project.ios</a>
<br />Follow: <a href="https://github.com/coderZsq">coderZsq · GitHub</a>
<br />Resume: <a href="https://coderzsq.github.io/coderZsq.practice.web/">https://coderzsq.github.io/coderZsq.practice.web/</a></p>
</blockquote>

<h4 id="日常扯淡">日常扯淡</h4>

<p><code class="highlighter-rouge">emm~~~</code> 前段时间又出去看了看<code class="highlighter-rouge">iOS</code>市场的行情, 除非是<code class="highlighter-rouge">BAT</code>, <code class="highlighter-rouge">TMD</code>, 这类一线的知名企业, 其他的只要努努力还是可以通过的, 这里分享一些小技巧, 比如当<code class="highlighter-rouge">HR</code>,或者别人<code class="highlighter-rouge">内推</code>你的时候, 不管要求写的多么的<code class="highlighter-rouge">天花乱坠</code>, 千万不要被这些东西给吓到了, 你可以先<code class="highlighter-rouge">逆向</code>一下对方的项目, 了解一下工程架构及代码规范, 以及使用了哪些三方库, 其实都是在面试前很好的对对方的初步了解, 知己知彼当然就增添了一份胜算. 当然现在对<code class="highlighter-rouge">iOS</code>的要求也是参差不齐, <code class="highlighter-rouge">面试官</code>能力和视野的高低也会无形的给你入职造成一定的困扰, 就比如有一次, 面试官问, <code class="highlighter-rouge">能详细说说Swift么?</code>, 这种如此宽泛的命题, 你让我用什么角度来回答呢… <code class="highlighter-rouge">编译器层面?</code> <code class="highlighter-rouge">语言层面的写时复制?</code> <code class="highlighter-rouge">还是语法层面的?</code> 还是<code class="highlighter-rouge">WWDC</code>的新特性? 挑了一方面讲讲, 就被说<code class="highlighter-rouge">只有这些么?</code>, <code class="highlighter-rouge">能不能不要只说关键词?</code> 然后就是伴随着的<code class="highlighter-rouge">鄙视的眼神</code>… 关键是个<code class="highlighter-rouge">妹子</code>面试官, 而且在我<code class="highlighter-rouge">逆向</code>其项目时发现代码质量其实也就一般, 算了不吐槽了, <code class="highlighter-rouge">免得又要被说影响不好, 面试不过就瞎bb</code>~~</p>

<p>当然现在对于<code class="highlighter-rouge">iOS</code>的要求是比以前有了很大的提高, 只会用<code class="highlighter-rouge">OC</code>写个<code class="highlighter-rouge">tableview</code>现在是几乎很难找到工作了, 然而我除了公司的项目其他时间基本不会碰<code class="highlighter-rouge">OC</code>的代码, 所以当我要写这个<code class="highlighter-rouge">OC</code>版的性能优化的时候, 好多语法都不太记得都需要现查… 完全记不住<code class="highlighter-rouge">API</code>.</p>

<p>当然在做性能优化的时候, 你还是需要了解一些<code class="highlighter-rouge">C</code>系语言的底层知识, 这些虽然不一定能够在代码上能够体现, 但对于理解和设计是有非常大的帮助的, 而且现在网上的讲<code class="highlighter-rouge">底层原理</code>的博客实在是太多了, 都是你抄我我抄你的, 可能会有些许的水分, 建议还是从<code class="highlighter-rouge">runtime-723</code>, <code class="highlighter-rouge">GNUStep</code>, 这类源码来自己看会比较靠谱, 当然看这些代码的时候可能会看不太懂<code class="highlighter-rouge">C++</code>的语法, 可以去我的<code class="highlighter-rouge">github-page</code>上看看一些我整理的<code class="highlighter-rouge">C++</code>语法的总结, 应该会挺有帮助的.</p>

<h4 id="准备工作">准备工作</h4>

<p>对于界面的性能优化, 简单的说就是保持<code class="highlighter-rouge">界面流畅不掉帧</code>, 当然原理这种网上一搜一大把, 有空的话看看<code class="highlighter-rouge">YYKit</code>也就能够知晓个大概. 硬是要说原理的话, 就是当<code class="highlighter-rouge">Vsync信号</code>来临的<code class="highlighter-rouge">16.67ms</code>内<code class="highlighter-rouge">CPU</code>做完<code class="highlighter-rouge">排版</code>, <code class="highlighter-rouge">绘制</code>, <code class="highlighter-rouge">解码</code>, <code class="highlighter-rouge">GPU</code>避免<code class="highlighter-rouge">离屏渲染</code>之类的, 就会在<code class="highlighter-rouge">Runloop</code>下一次来临的时候渲染到屏幕上.</p>

<p>不说那么多原理了, 理论永远不如实践来的有意义, 这也是所谓的贝叶斯算法随时修正的策略. 我们先写一个测试数据来以备后面优化的需要.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">decodeURI</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"/fetchMockData"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>

        <span class="kd">let</span> <span class="nx">randomNumber</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">randomNumber</span> <span class="o">=</span> <span class="s2">""</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
                <span class="nx">randomNumber</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">randomNumber</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">randomString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="p">{</span><span class="err">　　</span>
           <span class="nx">len</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">||</span> <span class="mi">32</span><span class="p">;</span><span class="err">　　</span>
            <span class="kd">var</span> <span class="nx">$chars</span> <span class="o">=</span> <span class="s1">'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'</span><span class="p">;</span><span class="err">　　</span>
            <span class="kd">var</span> <span class="nx">maxPos</span> <span class="o">=</span> <span class="nx">$chars</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="err">　　</span>
            <span class="kd">var</span> <span class="nx">randomString</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span><span class="err">　　</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="err">　　　　</span>
                <span class="nx">randomString</span> <span class="o">+=</span> <span class="nx">$chars</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">maxPos</span><span class="p">));</span><span class="err">　　</span>
            <span class="p">}</span><span class="err">　　</span>
            <span class="k">return</span> <span class="nx">randomString</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="kd">let</span> <span class="nx">texts</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="kd">let</span> <span class="nx">images</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">randomNumber</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">texts</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">randomString</span><span class="p">(</span><span class="nx">randomNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">images</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">"https://avatars3.githubusercontent.com/u/19483268?s=40&amp;v=4"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">obj</span><span class="p">.</span><span class="nx">texts</span> <span class="o">=</span> <span class="nx">texts</span><span class="p">;</span>
            <span class="nx">obj</span><span class="p">.</span><span class="nx">images</span> <span class="o">=</span> <span class="nx">images</span><span class="p">;</span>
            <span class="nx">json</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">'Content-Type'</span><span class="p">:</span> <span class="s1">'application/json'</span>
        <span class="p">});</span>

        <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
            <span class="na">data</span><span class="p">:</span> <span class="nx">json</span><span class="p">,</span>
            <span class="na">status</span><span class="p">:</span> <span class="s1">'success'</span>
        <span class="p">}));</span>
    <span class="p">}</span> 

<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'listen port = 8080'</span><span class="p">);</span>
</code></pre>
</div>

<p>我就偷个懒用<code class="highlighter-rouge">javascript</code>起了个<code class="highlighter-rouge">node</code>服务器, 就是用来模拟测试数据用的, 当然如果你的机器没有<code class="highlighter-rouge">node</code>环境的话, 建议你去自行安装.</p>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-3af1fcbfae37275b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>完成之后, 我们通过浏览器访问就能够得到测试数据, 测试数据分为两块, 一块是文字, 一块是图片的<code class="highlighter-rouge">url</code>, 由于嫌麻烦, 直接就使用了我<code class="highlighter-rouge">github</code>的头像.</p>

<h4 id="预排版">预排版</h4>

<p>对于界面流畅, 第一个想到的就是<code class="highlighter-rouge">预排版</code>了, 而且预排版的作用显著, 原理也很简单, 就是<code class="highlighter-rouge">异步预先计算</code>, <code class="highlighter-rouge">避免每次在layoutSubviews中</code>, cell重用的时候进行重复计算. 诶… 又要被说<code class="highlighter-rouge">只讲关键词</code>了… 但原理就是那么简单, 还能讲出个啥? 再说的细了代码就写出来了…</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cp">#import "Service.h"
#import &lt;AFNetworking.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">Service</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fetchMockDataWithParam</span><span class="p">:(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">parameter</span> <span class="nf">completion</span><span class="p">:(</span><span class="n">RequestCompletionBlock</span><span class="p">)</span><span class="nv">completion</span> <span class="p">{</span>
    
    <span class="n">AFHTTPSessionManager</span> <span class="o">*</span> <span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFHTTPSessionManager</span> <span class="nf">manager</span><span class="p">];</span>
    <span class="p">[</span><span class="n">manager</span> <span class="nf">GET</span><span class="p">:</span><span class="s">@"http://localhost:8080/fetchMockData"</span> <span class="nf">parameters</span><span class="p">:</span><span class="n">parameter</span> <span class="n">progress</span><span class="o">:</span><span class="nb">nil</span> <span class="n">success</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">task</span><span class="p">,</span> <span class="n">id</span>  <span class="n">_Nullable</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">responseObject</span><span class="p">[</span><span class="s">@"status"</span><span class="p">]</span> <span class="nf">isEqualToString</span><span class="p">:</span> <span class="s">@"success"</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">completion</span><span class="p">(</span><span class="n">responseObject</span><span class="p">[</span><span class="s">@"data"</span><span class="p">],</span> <span class="nb">nil</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLSessionDataTask</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">task</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">completion</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>
<p>当然你需要请求一下刚才的<code class="highlighter-rouge">模拟数据</code>, 注意<code class="highlighter-rouge">localhost</code>是<code class="highlighter-rouge">http</code>的需要强制越权.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cp">#import "ViewModel.h"
#import "ComponentModel.h"
#import "ComponentLayout.h"
#import "Element.h"
#import &lt;UIKit/UIKit.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">ViewModel</span>

<span class="k">-</span> <span class="p">(</span><span class="n">Service</span> <span class="o">*</span><span class="p">)</span><span class="n">service</span> <span class="p">{</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_service</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_service</span> <span class="o">=</span> <span class="p">[</span><span class="n">Service</span> <span class="nf">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_service</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">reloadData</span><span class="o">:</span><span class="p">(</span><span class="n">LayoutCompeltionBlock</span><span class="p">)</span><span class="n">completion</span> <span class="n">error</span><span class="o">:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">errorCompletion</span> <span class="p">{</span>
    
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">service</span> <span class="nf">fetchMockDataWithParam</span><span class="p">:</span><span class="nb">nil</span> <span class="nf">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">ComponentModel</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">models</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">"queue"</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">NSMutableArray</span> <span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nf">new</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">ComponentModel</span> <span class="o">*</span> <span class="n">model</span> <span class="k">in</span> <span class="n">models</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ComponentLayout</span> <span class="o">*</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">preLayoutFrom</span><span class="p">:</span><span class="n">model</span><span class="p">];</span>
                    <span class="p">[</span><span class="n">array</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">layout</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">completion</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">completion</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="p">});</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">errorCompletion</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">loadMoreData</span><span class="o">:</span><span class="p">(</span><span class="n">LayoutCompeltionBlock</span><span class="p">)</span><span class="n">completion</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">reloadData</span><span class="p">:</span><span class="n">completion</span> <span class="nf">error</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">ComponentLayout</span> <span class="o">*</span><span class="p">)</span><span class="n">preLayoutFrom</span><span class="o">:</span><span class="p">(</span><span class="n">ComponentModel</span> <span class="o">*</span><span class="p">)</span><span class="n">model</span> <span class="p">{</span>
    
    <span class="n">ComponentLayout</span> <span class="o">*</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">[</span><span class="n">ComponentLayout</span> <span class="nf">new</span><span class="p">];</span>
    <span class="n">layout</span><span class="p">.</span><span class="n">cellWidth</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIScreen</span> <span class="nf">mainScreen</span><span class="p">].</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    
    <span class="n">CGFloat</span> <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">CGFloat</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.;</span>
    <span class="n">CGFloat</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.;</span>
    <span class="n">CGFloat</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.;</span>
    
    <span class="n">NSMutableArray</span> <span class="o">*</span> <span class="n">textElements</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nf">array</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span> <span class="n">texts</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">@"texts"</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">texts</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span> <span class="n">text</span> <span class="o">=</span> <span class="n">texts</span><span class="p">[</span><span class="nf">i</span><span class="p">];</span>
        <span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">text</span> <span class="nf">boundingRectWithSize</span><span class="p">:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">MAXFLOAT</span><span class="p">,</span> <span class="n">MAXFLOAT</span><span class="p">)</span> <span class="nf">options</span><span class="p">:</span><span class="n">NSStringDrawingUsesLineFragmentOrigin</span> <span class="o">|</span> <span class="n">NSStringDrawingUsesFontLeading</span>  <span class="n">attributes</span><span class="o">:</span><span class="p">@{</span><span class="n">NSFontAttributeName</span> <span class="o">:</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nf">systemFontOfSize</span><span class="p">:</span><span class="mi">7</span><span class="p">]}</span> <span class="n">context</span><span class="o">:</span><span class="nb">nil</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">layout</span><span class="p">.</span><span class="n">cellWidth</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>

        <span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="o">=</span> <span class="p">[</span><span class="n">Element</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">element</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">text</span><span class="p">;</span>
        <span class="n">element</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
        <span class="p">[</span><span class="n">textElements</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">cursor</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.;</span>
    
    <span class="n">NSMutableArray</span> <span class="o">*</span> <span class="n">imageElements</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nf">array</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span> <span class="n">images</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">@"images"</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">images</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span> <span class="n">url</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="nf">i</span><span class="p">];</span>
        <span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">layout</span><span class="p">.</span><span class="n">cellWidth</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
            <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">cursor</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
        
        <span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="o">=</span> <span class="p">[</span><span class="n">Element</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">element</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">url</span><span class="p">;</span>
        <span class="n">element</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
        <span class="p">[</span><span class="n">imageElements</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">cursor</span> <span class="o">+=</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
    
    <span class="n">layout</span><span class="p">.</span><span class="n">cellHeight</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
    <span class="n">layout</span><span class="p">.</span><span class="n">textElements</span> <span class="o">=</span> <span class="n">textElements</span><span class="p">;</span>
    <span class="n">layout</span><span class="p">.</span><span class="n">imageElements</span> <span class="o">=</span> <span class="n">imageElements</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">layout</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupData</span><span class="p">:(</span><span class="n">ComponentLayout</span> <span class="o">*</span><span class="p">)</span><span class="nv">layout</span> <span class="nf">asynchronously</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">asynchronously</span> <span class="p">{</span>
    <span class="n">_layout</span> <span class="o">=</span> <span class="n">layout</span><span class="p">;</span> <span class="n">_asynchronously</span> <span class="o">=</span> <span class="n">asynchronously</span><span class="p">;</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">displayImageView</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asynchronously</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">layout</span><span class="p">.</span><span class="n">textElements</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">UILabel</span> <span class="o">*</span> <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="n">UILabel</span> <span class="o">*</span><span class="p">)[</span><span class="n">_labelReusePool</span> <span class="nf">dequeueReusableObject</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">label</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">UILabel</span> <span class="nf">new</span><span class="p">];</span>
                <span class="p">[</span><span class="n">_labelReusePool</span> <span class="nf">addUsingObject</span><span class="p">:</span><span class="n">label</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
            <span class="n">label</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
            <span class="n">label</span><span class="p">.</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nf">systemFontOfSize</span><span class="p">:</span><span class="mi">7</span><span class="p">];</span>
            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">contentView</span> <span class="nf">addSubview</span><span class="p">:</span><span class="n">label</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="p">[</span><span class="n">_labelReusePool</span> <span class="nf">reset</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>代码也是非常的简单, 即是根据获取的的数据进行排版而已, 然后<code class="highlighter-rouge">cell</code>直接获取排版后的<code class="highlighter-rouge">frame</code>进行一步赋值操作而已. 有兴趣也可以看看<code class="highlighter-rouge">sunnyxx</code>的<code class="highlighter-rouge">FDTemplateLayoutCell</code>.</p>

<h4 id="重用池">重用池</h4>

<p>眼尖的同学肯定就看到上面代码由类似于<code class="highlighter-rouge">cell</code>的重用机制, 这个其实就是下面要讲到的重用池的概念, 原理也是非常简单的, 就是维护了两个队列, 一个是当前队列, 一个是可重用队列.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cp">#import "ReusePool.h"
</span>
<span class="k">@interface</span> <span class="nc">ReusePool</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableSet</span> <span class="o">*</span> <span class="n">waitUsedQueue</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableSet</span> <span class="o">*</span> <span class="n">usingQueue</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSLock</span> <span class="o">*</span> <span class="n">lock</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ReusePool</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_waitUsedQueue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="nf">set</span><span class="p">];</span>
        <span class="n">_usingQueue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="nf">set</span><span class="p">];</span>
        <span class="n">_lock</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLock</span> <span class="nf">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="n">dequeueReusableObject</span> <span class="p">{</span>
    
    <span class="n">NSObject</span> <span class="o">*</span> <span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">_waitUsedQueue</span> <span class="nf">anyObject</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">_lock</span> <span class="nf">lock</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_waitUsedQueue</span> <span class="nf">removeObject</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_usingQueue</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_lock</span> <span class="nf">unlock</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">object</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addUsingObject</span><span class="o">:</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">_usingQueue</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">reset</span> <span class="p">{</span>
    <span class="n">NSObject</span> <span class="o">*</span> <span class="n">object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">_usingQueue</span> <span class="nf">anyObject</span><span class="p">]))</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">_lock</span> <span class="nf">lock</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_usingQueue</span> <span class="nf">removeObject</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_waitUsedQueue</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
        <span class="p">[</span><span class="n">_lock</span> <span class="nf">unlock</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>
<p>这里由于我这个重用队列, 并不仅仅针对于<code class="highlighter-rouge">UI</code>, 所以在多线程访问的情况下, 是需要加锁处理的, 这里就用最通用的<code class="highlighter-rouge">pthread-mutex</code>进行加锁.</p>

<h4 id="预解码">预解码</h4>

<p>这里做的就是通过<code class="highlighter-rouge">url</code>进行的异步解码的处理, 相关原理的文章其实很多, 自行查阅.</p>

<pre><code class="language-objctive-c">@implementation NSString (Extension)

- (void)preDecodeThroughQueue:(dispatch_queue_t)queue completion:(void(^)(UIImage *))completion {
    
    dispatch_async(queue, ^{
        CGImageRef cgImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:self]]].CGImage;
        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) &amp; kCGBitmapAlphaInfoMask;
        
        BOOL hasAlpha = NO;
        if (alphaInfo == kCGImageAlphaPremultipliedLast ||
            alphaInfo == kCGImageAlphaPremultipliedFirst ||
            alphaInfo == kCGImageAlphaLast ||
            alphaInfo == kCGImageAlphaFirst) {
            hasAlpha = YES;
        }
        
        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;
        
        size_t width = CGImageGetWidth(cgImage);
        size_t height = CGImageGetHeight(cgImage);
        
        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);
        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);
        cgImage = CGBitmapContextCreateImage(context);
        
        UIImage * image = [[UIImage imageWithCGImage:cgImage] cornerRadius:width * 0.5];
        CGContextRelease(context);
        CGImageRelease(cgImage);
        completion(image);
    });
}

@end
</code></pre>

<h4 id="预渲染">预渲染</h4>

<p>比如<code class="highlighter-rouge">imageView.layer.cornerRadius</code>及<code class="highlighter-rouge">imageView.layer.masksToBounds = YES;</code>这类操作会导致<code class="highlighter-rouge">离屏渲染</code>, <code class="highlighter-rouge">GPU</code>会导致新开缓冲区造成消耗. 为了避免离屏渲染，你应当尽量避免使用 <code class="highlighter-rouge">layer</code> 的 <code class="highlighter-rouge">border</code>、<code class="highlighter-rouge">corner</code>、<code class="highlighter-rouge">shadow</code>、<code class="highlighter-rouge">mask</code> 等技术，而尽量在后台线程预先绘制好对应内容。这种<code class="highlighter-rouge">SDWebImage</code>的缓存策略是有很大的参考意义的.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIImage</span> <span class="p">(</span><span class="nl">Extension</span><span class="p">)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">cornerRadius</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">cornerRadius</span> <span class="p">{</span>
    
    <span class="n">CGRect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="n">UIBezierPath</span> <span class="o">*</span> <span class="n">bezierPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nf">bezierPathWithRoundedRect</span><span class="p">:</span><span class="n">rect</span> <span class="nf">cornerRadius</span><span class="p">:</span><span class="n">cornerRadius</span><span class="p">];</span>
    <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="p">[</span><span class="n">UIScreen</span> <span class="nf">mainScreen</span><span class="p">].</span><span class="n">scale</span><span class="p">);</span>
    <span class="n">CGContextAddPath</span><span class="p">(</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">(),</span> <span class="n">bezierPath</span><span class="p">.</span><span class="n">CGPath</span><span class="p">);</span>
    <span class="n">CGContextClip</span><span class="p">(</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">());</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">drawInRect</span><span class="p">:</span><span class="n">rect</span><span class="p">];</span>
    
    <span class="n">CGContextDrawPath</span><span class="p">(</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">(),</span> <span class="n">kCGPathFillStroke</span><span class="p">);</span>
    <span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
    <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre>
</div>
<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">displayImageView</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">_layout</span><span class="p">.</span><span class="n">imageElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">UIImageView</span> <span class="o">*</span> <span class="n">imageView</span> <span class="o">=</span> <span class="p">(</span><span class="n">UIImageView</span> <span class="o">*</span><span class="p">)[</span><span class="n">_imageReusePool</span> <span class="nf">dequeueReusableObject</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">imageView</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">imageView</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImageView</span> <span class="nf">new</span><span class="p">];</span>
            <span class="p">[</span><span class="n">_imageReusePool</span> <span class="nf">addUsingObject</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">dequeueReusableObject</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">NSString</span> <span class="o">*</span> <span class="n">url</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
            <span class="p">[</span><span class="n">url</span> <span class="nf">preDecodeThroughQueue</span><span class="p">:</span><span class="n">concurrentQueue</span> <span class="nf">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">addUsingObject</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
                <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
                    <span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
                <span class="p">});</span>
            <span class="p">}];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">imageView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">contentView</span> <span class="nf">addSubview</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">reset</span><span class="p">];</span>
    <span class="p">[</span><span class="n">_imageReusePool</span> <span class="nf">reset</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这样通过和重用池的结合就可以达到很好的效果, 当然因为我这里是一张相同的图片, 正常情况下需要设计一整套的缓存策略, <code class="highlighter-rouge">hash</code>一下<code class="highlighter-rouge">url</code>什么的.</p>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-71791b43740e3c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="375" style="margin: clear: both; display: block; margin:auto; 0;" /></p>

<p>通过上述的方案结合, 我们已经能够比较流畅的显示那么多数据了 而且帧数还是不错的, 但还有优化的空间.</p>

<h4 id="异步绘制">异步绘制</h4>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-8327f8a8352da242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>进过了上面的优化, 我们其实已经做的不错了, 但是看下界面的层次, 是不是有点得了密集恐惧症… 接下来要讲的异步绘制就能够很好的解决这个问题. 并更加的优化流畅度.
异步绘制的原理么, 就是异步的<code class="highlighter-rouge">drawInLayer</code>, 异步的画在上下文上并统一绘制.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">displayLayer</span><span class="p">:(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="nv">layer</span> <span class="p">{</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">layer</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">layer</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">AsyncDrawLayer</span> <span class="nf">class</span><span class="p">]])</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">isAsynchronously</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">AsyncDrawLayer</span> <span class="o">*</span><span class="n">tempLayer</span> <span class="o">=</span> <span class="p">(</span><span class="n">AsyncDrawLayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span><span class="p">;</span>
    <span class="p">[</span><span class="n">tempLayer</span> <span class="nf">increaseCount</span><span class="p">];</span>
    
    <span class="n">NSUInteger</span> <span class="n">oldCount</span> <span class="o">=</span> <span class="n">tempLayer</span><span class="p">.</span><span class="n">drawsCount</span><span class="p">;</span>
    <span class="n">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
    <span class="n">UIColor</span> <span class="o">*</span> <span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">;</span>
    
    <span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">failedBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@"displayLayer failed"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tempLayer</span><span class="p">.</span><span class="n">drawsCount</span> <span class="o">!=</span> <span class="n">oldCount</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">failedBlock</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">CGSize</span> <span class="n">contextSize</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="n">BOOL</span> <span class="n">contextSizeValid</span> <span class="o">=</span> <span class="n">contextSize</span><span class="p">.</span><span class="n">width</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">contextSize</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">contextSizeValid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">contextSize</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">isOpaque</span><span class="p">,</span> <span class="n">layer</span><span class="p">.</span><span class="n">contentsScale</span><span class="p">);</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
            <span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">backgroundColor</span> <span class="o">&amp;&amp;</span> <span class="n">backgroundColor</span> <span class="o">!=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">clearColor</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">backgroundColor</span><span class="p">.</span><span class="n">CGColor</span><span class="p">);</span>
                <span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">asyncDraw</span><span class="p">:</span><span class="nb">YES</span> <span class="nf">context</span><span class="p">:</span><span class="n">context</span> <span class="n">completion</span><span class="o">:^</span><span class="p">(</span><span class="n">BOOL</span> <span class="n">drawingFinished</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">drawingFinished</span> <span class="o">&amp;&amp;</span> <span class="n">oldCount</span> <span class="o">==</span> <span class="n">tempLayer</span><span class="p">.</span><span class="n">drawsCount</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">CGImageRef</span> <span class="n">CGImage</span> <span class="o">=</span> <span class="n">context</span> <span class="p">?</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>
                    <span class="p">{</span>
                        <span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="n">CGImage</span> <span class="p">?</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithCGImage</span><span class="p">:</span><span class="n">CGImage</span><span class="p">]</span> <span class="p">:</span> <span class="nb">nil</span><span class="p">;</span>
                        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">oldCount</span> <span class="o">!=</span> <span class="n">tempLayer</span><span class="p">.</span><span class="n">drawsCount</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">failedBlock</span><span class="p">();</span>
                                <span class="k">return</span><span class="p">;</span>
                            <span class="p">}</span>
                            <span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
                            <span class="n">layer</span><span class="p">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
                            <span class="p">[</span><span class="n">UIView</span> <span class="nf">animateWithDuration</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">25</span> <span class="nf">delay</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="n">options</span><span class="o">:</span><span class="n">UIViewAnimationOptionAllowUserInteraction</span> <span class="n">animations</span><span class="o">:^</span><span class="p">{</span>
                                <span class="n">layer</span><span class="p">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
                            <span class="p">}</span> <span class="n">completion</span><span class="o">:</span><span class="nb">NULL</span><span class="p">];</span>
                        <span class="p">});</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">CGImage</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">CGImage</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">failedBlock</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}];</span>
            <span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>

<p>代码其实也没什么好讲的只要注意下多线程重绘时的问题也就可以了.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">asyncDraw</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">asynchronously</span> <span class="nf">context</span><span class="p">:(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">context</span> <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">BOOL</span><span class="p">))</span><span class="nv">completion</span> <span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">_layout</span><span class="p">.</span><span class="n">textElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSMutableParagraphStyle</span> <span class="o">*</span> <span class="n">paragraphStyle</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSParagraphStyle</span> <span class="nf">defaultParagraphStyle</span><span class="p">]</span> <span class="nf">mutableCopy</span><span class="p">];</span>
        <span class="n">paragraphStyle</span><span class="p">.</span><span class="n">lineBreakMode</span> <span class="o">=</span> <span class="n">NSLineBreakByCharWrapping</span><span class="p">;</span>
        <span class="n">paragraphStyle</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">NSTextAlignmentCenter</span><span class="p">;</span>
        <span class="p">[</span><span class="n">element</span><span class="p">.</span><span class="n">value</span> <span class="nf">drawInRect</span><span class="p">:</span><span class="n">element</span><span class="p">.</span><span class="n">frame</span> <span class="nf">withAttributes</span><span class="p">:@{</span><span class="n">NSFontAttributeName</span><span class="o">:</span><span class="p">[</span><span class="n">UIFont</span> <span class="nf">systemFontOfSize</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span>
                                                                 <span class="nl">NSForegroundColorAttributeName:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nf">blackColor</span><span class="p">],</span>
                                                                 <span class="nl">NSParagraphStyleAttributeName:</span><span class="n">paragraphStyle</span><span class="p">}];</span>
    <span class="p">}</span>
    <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-31df2534bcb135e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
当在当前线程全部绘制完上下文后, 会统一的渲染到<code class="highlighter-rouge">layer</code>上, 很好理解的其实.</p>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-83a4c77d9600768f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="375" style="margin: clear: both; display: block; margin:auto; 0;" /></p>

<p>这样我们的图层就会被合成, 帧率也一直保持在60帧的样子.</p>

<h4 id="语法技巧">语法技巧</h4>

<p><code class="highlighter-rouge">OC</code>现在也支持类属性了, 具体的使用可以看我<code class="highlighter-rouge">swift</code>的<a href="https://github.com/coderZsq/coderZsq.practice.native/tree/master/StudyNotes/DesignPatterns/Render%20Tree">renderTree</a>.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">@property</span> <span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">,</span><span class="n">strong</span><span class="p">)</span> <span class="n">ReusePool</span> <span class="o">*</span> <span class="n">asyncReusePool</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ReusePool</span> <span class="o">*</span> <span class="n">_asyncReusePool</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>

<span class="k">+</span> <span class="p">(</span><span class="n">ReusePool</span> <span class="o">*</span><span class="p">)</span><span class="n">asyncReusePool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_asyncReusePool</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_asyncReusePool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ReusePool</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_asyncReusePool</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setAsyncReusePool</span><span class="o">:</span><span class="p">(</span><span class="n">ReusePool</span> <span class="o">*</span><span class="p">)</span><span class="n">asyncReusePool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_asyncReusePool</span> <span class="o">!=</span> <span class="n">asyncReusePool</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_asyncReusePool</span> <span class="o">=</span> <span class="n">asyncReusePool</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="碰到的坑">碰到的坑</h4>

<p>其实理想的效果是如下图这样的. 所有的图片都被异步绘制到<code class="highlighter-rouge">layer</code>上.
<img src="https://upload-images.jianshu.io/upload_images/12332870-e9df99e1c8af4765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">asyncDraw</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">asynchronously</span> <span class="nf">context</span><span class="p">:(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">context</span> <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">BOOL</span><span class="p">))</span><span class="nv">completion</span> <span class="p">{</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">_layout</span><span class="p">.</span><span class="n">textElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSMutableParagraphStyle</span> <span class="o">*</span> <span class="n">paragraphStyle</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSParagraphStyle</span> <span class="nf">defaultParagraphStyle</span><span class="p">]</span> <span class="nf">mutableCopy</span><span class="p">];</span>
        <span class="n">paragraphStyle</span><span class="p">.</span><span class="n">lineBreakMode</span> <span class="o">=</span> <span class="n">NSLineBreakByCharWrapping</span><span class="p">;</span>
        <span class="n">paragraphStyle</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">NSTextAlignmentCenter</span><span class="p">;</span>
        <span class="p">[</span><span class="n">element</span><span class="p">.</span><span class="n">value</span> <span class="nf">drawInRect</span><span class="p">:</span><span class="n">element</span><span class="p">.</span><span class="n">frame</span> <span class="nf">withAttributes</span><span class="p">:@{</span><span class="n">NSFontAttributeName</span><span class="o">:</span><span class="p">[</span><span class="n">UIFont</span> <span class="nf">systemFontOfSize</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span>
                                                                 <span class="nl">NSForegroundColorAttributeName:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nf">blackColor</span><span class="p">],</span>
                                                                 <span class="nl">NSParagraphStyleAttributeName:</span><span class="n">paragraphStyle</span><span class="p">}];</span>
    <span class="p">}</span>
    <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
    <span class="c1">//TODO:
</span>    <span class="c1">//    for (Element * element in _layout.imageElements) {
</span>    <span class="c1">//        UIImage * image = (UIImage *)[ComponentCell.asyncReusePool dequeueReusableObject];
</span>    <span class="c1">//        if (!image) {
</span>    <span class="c1">//            NSString * url = element.value;
</span>    <span class="c1">//            [url preDecodeThroughQueue:concurrentQueue completion:^(UIImage * image) {
</span>    <span class="c1">//                [ComponentCell.asyncReusePool addUsingObject:image];
</span>    <span class="c1">//                [image drawInRect:element.frame]; //这里异步回调上下文获取不到报错
</span>    <span class="c1">//                completion(YES);
</span>    <span class="c1">//            }];
</span>    <span class="c1">//        } else {
</span>    <span class="c1">//            [image drawInRect:element.frame];
</span>    <span class="c1">//            completion(YES);
</span>    <span class="c1">//        }
</span>    <span class="c1">//    }
</span>    <span class="c1">//    [_asyncReusePool reset];
</span><span class="p">}</span>
</code></pre>
</div>

<p>但这里碰到一个问题, <code class="highlighter-rouge">CGContextRef</code>, 也就是<code class="highlighter-rouge">UIGraphicsGetCurrentContext()</code>拿到的是当前线程的上下文, 而线程和<code class="highlighter-rouge">Runloop</code>是一一对应的, 只有当前线程的上下文才能进行绘制, 而网络图片又需要进行<code class="highlighter-rouge">异步下载解码</code>, 势必会进行并发下载, 从而上下文获取不到, 绘制不能.报错如下:</p>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-295d67198a0610ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>我尝试了一下将绘图上下文传入其他线程并渲染:</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">_layout</span><span class="p">.</span><span class="n">imageElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">dequeueReusableObject</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">NSString</span> <span class="o">*</span> <span class="n">url</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
            <span class="p">[</span><span class="n">url</span> <span class="nf">preDecodeThroughQueue</span><span class="p">:</span><span class="n">concurrentQueue</span> <span class="nf">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">addUsingObject</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
                <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
                <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
            <span class="p">}];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">image</span> <span class="nf">drawInRect</span><span class="p">:</span><span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">];</span>
            <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">_asyncReusePool</span> <span class="nf">reset</span><span class="p">];</span>
</code></pre>
</div>
<p>可惜的是, 使用<code class="highlighter-rouge">CGContextDrawImage</code>传入当前上下文也不能解决这个问题, 原因是上一个线程的上下文已经过期了…</p>

<p><img src="https://upload-images.jianshu.io/upload_images/12332870-9cf9655bf41931b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<h4 id="常驻线程">常驻线程</h4>

<p>碰到这个问题, 首先想到的就是可能是在上一条线程挂了之后, <code class="highlighter-rouge">context</code>失效导致的, 那我们可以使用<code class="highlighter-rouge">runloop</code>开启一条常驻线程来保住这个上下文.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="cp">#import "PermenantThread.h"
</span>
<span class="k">@interface</span> <span class="nc">Thread</span> <span class="p">:</span> <span class="nc">NSThread</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Thread</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%s"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">PermenantThread</span><span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">Thread</span> <span class="o">*</span><span class="n">innerThread</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">PermenantThread</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Thread</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
            <span class="n">CFRunLoopSourceContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
            <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span> <span class="o">=</span> <span class="n">CFRunLoopSourceCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
            <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">source</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
            <span class="n">CFRelease</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
            <span class="n">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mf">1.0e10</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="p">}];</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="nf">start</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>


<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">executeTask</span><span class="o">:</span><span class="p">(</span><span class="n">PermenantThreadTask</span><span class="p">)</span><span class="n">task</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="o">||</span> <span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">__executeTask</span><span class="p">:)</span> <span class="n">onThread</span><span class="o">:</span><span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="n">withObject</span><span class="o">:</span><span class="n">task</span> <span class="n">waitUntilDone</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stop</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">innerThread</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">__stop</span><span class="p">)</span> <span class="nf">onThread</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="n">withObject</span><span class="o">:</span><span class="nb">nil</span> <span class="n">waitUntilDone</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%s"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">stop</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">__stop</span> <span class="p">{</span>
    <span class="n">CFRunLoopStop</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">());</span>
    <span class="n">self</span><span class="p">.</span><span class="n">innerThread</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">__executeTask</span><span class="o">:</span><span class="p">(</span><span class="n">PermenantThreadTask</span><span class="p">)</span><span class="n">task</span> <span class="p">{</span>
    <span class="n">task</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">@end</span>

</code></pre>
</div>

<p>然而在原以为是因为<code class="highlighter-rouge">子线程销毁</code>导致的<code class="highlighter-rouge">上下文过期</code>, 在我用<code class="highlighter-rouge">Runloop</code>做了一个常驻线程后, 一样没有效果… 真是醉了… 谁知道上下文过期会是什么造成的么?</p>

<h4 id="解决方法">解决方法</h4>

<p>查了一些资料和问了一些大佬, 得到各种反馈的解决方案, <code class="highlighter-rouge">dispath_async_f</code>这个函数是没有用的, 传递的上下文和绘图上下文并没有关系, 所以这个是不对的, 最后尝试使用自建上下文解决了这个问题.</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code><span class="n">CGColorSpaceRef</span> <span class="n">colorSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
<span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">contextSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">contextSize</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">contextSize</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">kCGImageAlphaPremultipliedFirst</span> <span class="o">|</span> <span class="n">kCGImageByteOrderDefault</span><span class="p">);</span>
<span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">colorSpace</span><span class="p">);</span>
<span class="n">CGAffineTransform</span> <span class="n">normalState</span> <span class="o">=</span> <span class="n">CGContextGetCTM</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">CGContextConcatCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">normalState</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">backgroundColor</span> <span class="o">&amp;&amp;</span> <span class="n">backgroundColor</span> <span class="o">!=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">clearColor</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">backgroundColor</span><span class="p">.</span><span class="n">CGColor</span><span class="p">);</span>
    <span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</code></pre>
</div>
<p>绘图的时候不使用<code class="highlighter-rouge">drawInRect</code>, 而使用<code class="highlighter-rouge">CGContextDrawImage</code>的API</p>

<div class="language-objc highlighter-rouge"><pre class="highlight"><code>    <span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
    <span class="n">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">"concurrent"</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Element</span> <span class="o">*</span> <span class="n">element</span> <span class="k">in</span> <span class="n">_layout</span><span class="p">.</span><span class="n">imageElements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">dequeueReusableObject</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
            <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">NSString</span> <span class="o">*</span> <span class="n">url</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
                <span class="p">[</span><span class="n">url</span> <span class="nf">preDecodeWithCGCoordinateSystem</span><span class="p">:</span><span class="nb">YES</span> <span class="nf">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
                    <span class="p">[</span><span class="n">ComponentCell</span><span class="p">.</span><span class="n">asyncReusePool</span> <span class="nf">addUsingObject</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
                    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
<span class="c1">//                    completion(YES);
</span>                <span class="p">}];</span>
                <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">);</span>
            <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">completion</span><span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="p">[</span><span class="n">_asyncReusePool</span> <span class="nf">reset</span><span class="p">];</span>
</code></pre>
</div>
<p>由于是异步绘制, 每下载一张图片就进行绘制, 会造成一直刷帧, 所以使用线程组来进行统一绘制.</p>

<p>这里还有一个坑就是 <code class="highlighter-rouge">drawInRect</code>和<code class="highlighter-rouge">CGContextDrawImage </code>的绘制坐标系不一样, 所以需要加一下判断即可.</p>

<p>最后 本文中所有的源码都可以在github上找到 -&gt; <a href="https://github.com/coderZsq/coderZsq.project.ios/tree/master/SQPerformance">SQPerformance</a></p>
<blockquote>
  <p>GitHub Repo：<a href="https://github.com/coderZsq/coderZsq.project.ios">coderZsq.project.ios</a>
<br />Follow: <a href="https://github.com/coderZsq">coderZsq · GitHub</a>
<br />Resume: <a href="https://coderzsq.github.io/coderZsq.practice.web/">https://coderzsq.github.io/coderZsq.practice.web/</a></p>
</blockquote>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/08/iOS-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B5%85%E6%9E%90/" title="link to iOS 网络性能优化浅析">iOS 网络性能优化浅析</a></h2>
       <p class="excerpt">  GitHub Repo：coderZsq.project.iosFollow: coderZsq · GitHubResume: https://coderzsq.github.io/coderZsq.practice.web/日常扯淡emm~~ 最近有好多大厂疯狂招人, 也有很多朋友抛出了橄榄枝要来内推我, 在此我表示万分感谢, 但以小弟的简历… 真的连简历都过不了… 最近在学习Python, 真的学了Python才感受到了编程的乐趣啊, 爬虫, 自动化, 数据分析, 机器学习, 区...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-08-23 17:30:00 +0800" class="post-list__meta--date date">2018-08-23</time> &#8226; <span class="post-list__meta--tags tags">移动开发</span><a class="btn-border-small" href=/2018/08/iOS-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B5%85%E6%9E%90/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/05/Swift-%E8%BF%9B%E9%98%B6-%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/" title="link to Swift 进阶 | 看得见的算法">Swift 进阶 | 看得见的算法</a></h2>
       <p class="excerpt">  GitHub Repo：coderZsq.target.swiftFollow: coderZsq · GitHubResume: https://coderzsq.github.io/coderZsq.webpack.js/#/日常扯淡前段日子写了篇面经, 得到了掘金的征文活动的三等奖还是非常开心, 但是被寒神说面试不过就泄题, 影响不好, 我想想也是, 马上就把大厂的名字给抹掉了, 但被转载的就无能为力了, 看到下面好多喷的, 真是背后一凉, 一首凉凉送给自己, 造成的伤害无法挽回...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-05-18 22:46:00 +0800" class="post-list__meta--date date">2018-05-18</time> &#8226; <span class="post-list__meta--tags tags">移动开发</span><a class="btn-border-small" href=/2018/05/Swift-%E8%BF%9B%E9%98%B6-%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-09-16 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="https://github.com/coderZsq">@Castie!</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
