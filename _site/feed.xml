<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Castie!</title>
    <description>北冥有鱼，其名为鲲（kūn）。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 16 Dec 2017 17:04:16 +0800</pubDate>
    <lastBuildDate>Sat, 16 Dec 2017 17:04:16 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Animations 核心动画什么的要研究透!</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;看过我去年文章的同学们一定知道对于动画方面还是有点心得体会的, 对于核心动画的学习, 之前我看的是&lt;a href=&quot;http://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC/ref=sr_1_1?ie=UTF8&amp;amp;qid=1423192842&amp;amp;sr=8-1&amp;amp;keywords=Core+Animation+Advanced+Techniques&quot;&gt;iOS Core Animation&lt;/a&gt;的&lt;a href=&quot;http://wiki.jikexueyuan.com/project/ios-core-animation/&quot;&gt;翻译版&lt;/a&gt;, 看完感觉真的学到了不少东西, 不过这本书已经有点时日了, 我们需要与时俱进学习最前沿的技术.代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-8f8d322fd1b24ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和之前的View的动画一样, 这次Layer的核心动画, 我们也是先细讲API, 再进行项目实战, 这样会比较容易理解, 新入行的同学不会望而却步.其实刚学习核心动画的时候还有有点难度的, 先提两个注意点: 1) 相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;center&lt;/code&gt;, 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;layer&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;anchorPoint&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;(0.5, 0.5)&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;layer&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;anchorPoint&lt;/code&gt;其实是同一个点.2) &lt;code class=&quot;highlighter-rouge&quot;&gt;layer&lt;/code&gt;的动画其实是假象而且会被打断, &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;的动画是直接操作节点的. 好了, 我们来看今天所要掌握的API:&lt;/p&gt;

&lt;p&gt;基础动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 2.0, *)
open class CABasicAnimation : CAPropertyAnimation 
    open var fromValue: Any?
    open var toValue: Any?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;fromValue 根据&lt;code class=&quot;highlighter-rouge&quot;&gt;keyPath&lt;/code&gt;设定原始值&lt;/li&gt;
  &lt;li&gt;toValue 根据&lt;code class=&quot;highlighter-rouge&quot;&gt;keyPath&lt;/code&gt;设定目标值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键帧动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 2.0, *)
open class CAKeyframeAnimation : CAPropertyAnimation 
    open var values: [Any]?
    open var path: CGPath?
    open var keyTimes: [NSNumber]?
    open var timingFunctions: [CAMediaTimingFunction]?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;values 关键帧 的值 [x, x, x, …]&lt;/li&gt;
  &lt;li&gt;path 关键帧路径, 贝塞尔曲线&lt;/li&gt;
  &lt;li&gt;keyTimes 每帧的耗时, 以秒作为计量单位&lt;/li&gt;
  &lt;li&gt;timingFunctions 缓冲函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动画组:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 2.0, *)
open class CAAnimationGroup : CAAnimation
    open var animations: [CAAnimation]?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;animations 动画组数组, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;CAAnimation&lt;/code&gt;填入数组 进行组动画&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弹簧动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 9.0, *)
open class CASpringAnimation : CABasicAnimation
    open var mass: CGFloat 
    open var stiffness: CGFloat
    open var damping: CGFloat
    open var initialVelocity: CGFloat
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;mass 物体的质量&lt;/li&gt;
  &lt;li&gt;stiffness 弹簧的刚度&lt;/li&gt;
  &lt;li&gt;damping 缓冲率 也称阻尼值&lt;/li&gt;
  &lt;li&gt;initialVelocity 初始速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动画代理, 进行操作监听&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public protocol CAAnimationDelegate : NSObjectProtocol
    @available(iOS 2.0, *)
    optional public func animationDidStart(_ anim: CAAnimation)
    @available(iOS 2.0, *)
    optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;animationDidStart 动画开始前调用&lt;/li&gt;
  &lt;li&gt;animationDidStop 动画结束后调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CAMediaTiming 协议&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public protocol CAMediaTiming 
    public var beginTime: CFTimeInterval { get set }
    public var duration: CFTimeInterval { get set }
    public var speed: Float { get set }
    public var repeatCount: Float { get set }
    public var autoreverses: Bool { get set }
    public var fillMode: String { get set }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;beginTime 动画开始时间, 对比view动画的&lt;code class=&quot;highlighter-rouge&quot;&gt;delay&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;duration 动画持续时间&lt;/li&gt;
  &lt;li&gt;speed 动画速度 以倍率计算, 父层设置子层叠加&lt;/li&gt;
  &lt;li&gt;repeatCount 重复数量&lt;/li&gt;
  &lt;li&gt;autoreverses 自动翻转&lt;/li&gt;
  &lt;li&gt;fillMode 填充方式, 是否显示第一帧和最后一帧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;讲完API, 我们就来使用这些API进行实战, 和之前一样, 我们就通过Stroyboard搭建界面:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-e3c718347ac66709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 @IBOutlet 进行关联&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @IBOutlet var loginButton: UIButton! //登录按钮
    @IBOutlet var heading: UILabel! //顶部标签
    @IBOutlet var username: UITextField! //用户名输入框
    @IBOutlet var password: UITextField! //密码输入框
    
    @IBOutlet var cloud1: UIImageView! // 四片云
    @IBOutlet var cloud2: UIImageView!
    @IBOutlet var cloud3: UIImageView!
    @IBOutlet var cloud4: UIImageView!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在控制器的view将要显示的时候进行动画设置:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        let formGroup = CAAnimationGroup() //创建动画组
        formGroup.duration = 0.5 //设置组动画时长为0.5秒
        formGroup.fillMode = kCAFillModeBackwards //将填充模式设置为显示最后一帧
        
        let flyRight = CABasicAnimation(keyPath: &quot;position.x&quot;) //创建基础动画, keyPath设置为横向位移
        flyRight.fromValue = -view.bounds.size.width/2 //设置keyPath: &quot;position.x&quot;的起始位置
        flyRight.toValue = view.bounds.size.width/2 //设置keyPath: &quot;position.x&quot;的目标位置
        
        let fadeFieldIn = CABasicAnimation(keyPath: &quot;opacity&quot;) //创建基础动画, keyPath设置为透明率
        fadeFieldIn.fromValue = 0.25 设置keyPath: &quot;opacity&quot;的起始值
        fadeFieldIn.toValue = 1.0 设置keyPath: &quot;opacity&quot;的目标值
        
        formGroup.animations = [flyRight, fadeFieldIn] //将横向位移和透明率动画加入动画组
        heading.layer.add(formGroup, forKey: nil) //将动画添加到layer层上
        
        formGroup.delegate = self //设置代理, 监听动画进程
        formGroup.setValue(&quot;form&quot;, forKey: &quot;name&quot;) //KVC设置属性
        formGroup.setValue(username.layer, forKey: &quot;layer&quot;) //KVC设置属性
        
        formGroup.beginTime = CACurrentMediaTime() + 0.3 //动画开始时间, 从现在+0.3秒
        username.layer.add(formGroup, forKey: nil) //将动画添加到layer层上
        
        formGroup.setValue(password.layer, forKey: &quot;layer&quot;) //KVC设置属性
        formGroup.beginTime = CACurrentMediaTime() + 0.4 //动画开始时间, 从现在+0.4秒
        password.layer.add(formGroup, forKey: nil) //将动画添加到layer层上
        
        let fadeIn = CABasicAnimation(keyPath: &quot;opacity&quot;) 
        fadeIn.fromValue = 0.0
        fadeIn.toValue = 1.0
        fadeIn.duration = 0.5
        fadeIn.fillMode = kCAFillModeBackwards
        fadeIn.beginTime = CACurrentMediaTime() + 0.5
        cloud1.layer.add(fadeIn, forKey: nil)
        
        fadeIn.beginTime = CACurrentMediaTime() + 0.7
        cloud2.layer.add(fadeIn, forKey: nil)
        
        fadeIn.beginTime = CACurrentMediaTime() + 0.9
        cloud3.layer.add(fadeIn, forKey: nil)
        
        fadeIn.beginTime = CACurrentMediaTime() + 1.1
        cloud4.layer.add(fadeIn, forKey: nil)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在控制器的view已经显示的时候进行动画设置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        let groupAnimation = CAAnimationGroup()
        groupAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn) //添加缓冲函数
        groupAnimation.beginTime = CACurrentMediaTime() + 0.5
        groupAnimation.duration = 0.5
        groupAnimation.fillMode = kCAFillModeBackwards
        
        let scaleDown = CABasicAnimation(keyPath: &quot;transform.scale&quot;)
        scaleDown.fromValue = 3.5
        scaleDown.toValue = 1.0
        
        let rotate = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)
        rotate.fromValue = CGFloat(M_PI_4)
        rotate.toValue = 0.0
        
        let fade = CABasicAnimation(keyPath: &quot;opacity&quot;)
        fade.fromValue = 0.0
        fade.toValue = 1.0
        
        groupAnimation.animations = [scaleDown, rotate, fade]
        loginButton.layer.add(groupAnimation, forKey: nil)
        
        animateCloud(layer: cloud1.layer)
        animateCloud(layer: cloud2.layer)
        animateCloud(layer: cloud3.layer)
        animateCloud(layer: cloud4.layer)
        
        let flyLeft = CABasicAnimation(keyPath: &quot;position.x&quot;)
        flyLeft.fromValue = info.layer.position.x + view.frame.size.width
        flyLeft.toValue = info.layer.position.x
        flyLeft.duration = 5.0
        flyLeft.repeatCount = 2.5
        flyLeft.autoreverses = true
        info.layer.add(flyLeft, forKey: &quot;infoappear&quot;)
        
        let fadeLabelIn = CABasicAnimation(keyPath: &quot;opacity&quot;)
        fadeLabelIn.fromValue = 0.2
        fadeLabelIn.toValue = 1.0
        fadeLabelIn.duration = 4.5
        info.layer.add(fadeLabelIn, forKey: &quot;fadein&quot;)
        
        username.delegate = self
        password.delegate = self
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当登录按钮点击的时候设置动画&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @IBAction func login() {
        view.endEditing(true)
        
        ...

        let balloon = CALayer()
        balloon.contents = UIImage(named: &quot;balloon&quot;)!.cgImage //layer寄宿图设置
        balloon.frame = CGRect(x: -50.0, y: 0.0, width:
            50.0, height: 65.0)
        view.layer.insertSublayer(balloon, below: username.layer)
        
        let flight = CAKeyframeAnimation(keyPath: &quot;position&quot;) //添加关键帧动画
        flight.duration = 12.0
        flight.values = [ //NSValue结构值
            CGPoint(x: -50, y: 0.0),
            CGPoint(x: view.frame.width + 50.0, y: 160.0),
            CGPoint(x: -50.0, y: loginButton.center.y)
            ].map { NSValue(cgPoint: $0)} //进行map映射
        flight.keyTimes = [0.0, 0.5, 1.0]
        balloon.add(flight, forKey: nil)
        balloon.position = CGPoint(x: -50.0, y: loginButton.center.y)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;CAAnimationDelegate&lt;/code&gt;代理方法进行监听:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension ViewController: CAAnimationDelegate {
    func animationDidStop(_ anim: CAAnimation, finished flag: Bool) { //当动画结束后调用
        print(&quot;animation did finish&quot;)
        
        if let name = anim.value(forKey: &quot;name&quot;) as? String {
            if name == &quot;form&quot; { //拿到KVC的值
                //form field found
                let layer = anim.value(forKey: &quot;layer&quot;) as? CALayer
                anim.setValue(nil, forKey: &quot;layer&quot;) //清空KVC设值
                
                let pulse = CASpringAnimation(keyPath: &quot;transform.scale&quot;) //添加弹簧动画
                pulse.damping = 7.5 //阻尼率为7.5
                pulse.fromValue = 1.25
                pulse.toValue = 1.0
                pulse.duration = pulse.settlingDuration
                layer?.add(pulse, forKey: nil)
            }
            
            if name == &quot;cloud&quot; {
                guard let layer = anim.value(forKey: &quot;layer&quot;) as? CALayer else {
                    return
                }
                
                anim.setValue(nil, forKey: &quot;layer&quot;)
                
                layer.position.x = -layer.bounds.width/2
                delay(seconds: 0.5) {
                    self.animateCloud(layer: layer)
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;UITextFieldDelegate&lt;/code&gt;代理方法进行监听:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension ViewController: UITextFieldDelegate {
    func textFieldDidBeginEditing(_ textField: UITextField) {
        print(info.layer.animationKeys())
        info.layer.removeAnimation(forKey: &quot;infoappear&quot;) //当用户输入的时候移除动画
    }
    
    func textFieldDidEndEditing(_ textField: UITextField) {
        guard let text = textField.text else { return }
        if text.characters.count &amp;lt; 5 {
            // add animations here
            
            let jump = CASpringAnimation(keyPath: &quot;position.y&quot;) //当用户输入完成后添加弹簧动画
            jump.initialVelocity = 100.0 //初始速度为100
            jump.mass = 10.0 //layer的质量为10
            jump.stiffness = 1500.0 //弹簧刚度为1500
            jump.damping = 50.0 //阻尼率为50
            jump.fromValue = textField.layer.position.y + 1.0
            jump.toValue = textField.layer.position.y
            jump.duration = jump.settlingDuration //持续时间设置为系统认为合理的时间
            textField.layer.add(jump, forKey: nil)
            
            textField.layer.borderWidth = 3.0
            textField.layer.borderColor = UIColor.clear.cgColor
            
            let flash = CASpringAnimation(keyPath: &quot;borderColor&quot;)
            flash.damping = 7.0
            flash.stiffness = 200.0
            flash.fromValue = UIColor(red: 1.0, green: 0.27, blue: 0.0, alpha: 1.0).cgColor
            flash.toValue = UIColor.white.cgColor
            flash.duration = flash.settlingDuration
            textField.layer.add(flash, forKey: nil)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;演示效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-d737971df1e1fdd9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Apr 2017 10:44:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Animations-%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E4%BB%80%E4%B9%88%E7%9A%84%E8%A6%81%E7%A0%94%E7%A9%B6%E9%80%8F!/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Animations-%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E4%BB%80%E4%B9%88%E7%9A%84%E8%A6%81%E7%A0%94%E7%A9%B6%E9%80%8F!/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>Animations 你真的会用View的动画吗?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;RxSwift的学习我们先告一段落, 实在是太烧脑了, 今天我们换换脑子, 玩点轻松的动画, 去年我连载了一系列基于本人封装的Objective-C框架&lt;a href=&quot;https://github.com/coderZsq/coderZsq.project.oc&quot;&gt;SQExtension&lt;/a&gt;展开的项目实战, 里面关于动画方面的涉及还是蛮多的以至于受到了腾讯的关注. 这个系列我们就来细讲动画, 一起走上进阶之路. 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-8f8d322fd1b24ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于动画方面除了最基本的View动画之外, 关于Layer的核心动画我都是看这篇&lt;a href=&quot;http://wiki.jikexueyuan.com/project/ios-core-animation/&quot;&gt;wiki&lt;/a&gt;学的, 像去年连载的一些自定义转场动画是从&lt;a href=&quot;https://www.objccn.io/&quot;&gt;Objc&lt;/a&gt;中学的. 这次买了Ray家的一系列教程, 就打算将动画学透, 不再只是碎片化的知识.和连载RxSwift不同, 这次我们先带大家熟悉API以便更好的理解.&lt;/p&gt;

&lt;p&gt;这个应该是所有做动画最常用的方法了, 大多基本都是这个方法的变体.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 4.0, *)
    open class func animate(withDuration duration: TimeInterval, delay: TimeInterval, options: UIViewAnimationOptions = [], animations: @escaping () -&amp;gt; Swift.Void, completion: (@escaping (Bool) -&amp;gt; Swift.Void)? = nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;duration 持续时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;delay 延迟调用时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;options 动画选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;[], .x, [.x, .x, ...]&lt;/code&gt;等格式&lt;/li&gt;
  &lt;li&gt;animations 动画代码块, 执行可动画属性的改变&lt;/li&gt;
  &lt;li&gt;completion 动画完成后调用的尾随闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个是7.0开始使用的动画, 弹簧效果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 7.0, *)
    open class func animate(withDuration duration: TimeInterval, delay: TimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options: UIViewAnimationOptions = [], animations: @escaping () -&amp;gt; Swift.Void, completion: (@escaping (Bool) -&amp;gt; Swift.Void)? = nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;duration 持续时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;delay 延迟调用时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;usingSpringWithDamping 减震比率&lt;/li&gt;
  &lt;li&gt;initialSpringVelocity 初始速度&lt;/li&gt;
  &lt;li&gt;options 动画选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;[], .x, [.x, .x, ...]&lt;/code&gt;等格式&lt;/li&gt;
  &lt;li&gt;animations 动画代码块, 执行可动画属性的改变&lt;/li&gt;
  &lt;li&gt;completion 动画完成后调用的尾随闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个是关于UIView的转场动画, 可以对不可动画属性进行转场动画&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 4.0, *)
    open class func transition(with view: UIView, duration: TimeInterval, options: UIViewAnimationOptions = [], animations: (@escaping () -&amp;gt; Swift.Void)?, completion: (@escaping (Bool) -&amp;gt; Swift.Void)? = nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;view 进行转场的View&lt;/li&gt;
  &lt;li&gt;duration 持续时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;options 动画选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;[], .x, [.x, .x, ...]&lt;/code&gt;等格式&lt;/li&gt;
  &lt;li&gt;animations 动画代码块, 执行可动画属性的改变&lt;/li&gt;
  &lt;li&gt;completion 动画完成后调用的尾随闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个是从一个View转场至另一个View的动画&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 4.0, *)
    open class func transition(from fromView: UIView, to toView: UIView, duration: TimeInterval, options: UIViewAnimationOptions = [], completion: (@escaping (Bool) -&amp;gt; Swift.Void)? = nil) // toView added to fromView.superview, fromView removed from its superview
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;from 进行转场的View&lt;/li&gt;
  &lt;li&gt;to 转场后的View&lt;/li&gt;
  &lt;li&gt;duration 持续时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;options 动画选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;[], .x, [.x, .x, ...]&lt;/code&gt;等格式&lt;/li&gt;
  &lt;li&gt;completion 动画完成后调用的尾随闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键帧动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 7.0, *)
    open class func animateKeyframes(withDuration duration: TimeInterval, delay: TimeInterval, options: UIViewKeyframeAnimationOptions = [], animations: @escaping () -&amp;gt; Swift.Void, completion: (@escaping (Bool) -&amp;gt; Swift.Void)? = nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;duration 持续时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;delay 延迟调用时间 以秒作为单位&lt;/li&gt;
  &lt;li&gt;options 动画选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;[], .x, [.x, .x, ...]&lt;/code&gt;等格式&lt;/li&gt;
  &lt;li&gt;animations 动画代码块, 执行可动画属性的改变&lt;/li&gt;
  &lt;li&gt;completion 动画完成后调用的尾随闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;添加关键帧:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@available(iOS 7.0, *)
    open class func addKeyframe(withRelativeStartTime frameStartTime: Double, relativeDuration frameDuration: Double, animations: @escaping () -&amp;gt; Swift.Void) // start time and duration are values between 0.0 and 1.0 specifying time and duration relative to the overall time of the keyframe animation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;withRelativeStartTime 相对开始时间, 取值范围0~1, 按百分比取值&lt;/li&gt;
  &lt;li&gt;relativeDuration 相对持续时间 取值范围0~1, 按百分比取值&lt;/li&gt;
  &lt;li&gt;animations 动画代码块, 执行可动画属性的改变&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;API中涉及到的&lt;code class=&quot;highlighter-rouge&quot;&gt;options&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewAnimationOptions&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewKeyframeAnimationOptions&lt;/code&gt;中的枚举效果还是一个一个试会有更深的体会.&lt;/p&gt;

&lt;p&gt;讲完API, 我们就来使用这些API进行实战, 和之前一样, 我们就通过Stroyboard搭建界面:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-5da65a4d4bfafb70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过IBOutlet 进行关联&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @IBOutlet var bgImageView: UIImageView! //背景图片
  
  @IBOutlet var summaryIcon: UIImageView! //顶部图标
  @IBOutlet var summary: UILabel! //顶部文字
  
  @IBOutlet var flightNr: UILabel! //Flight文字
  @IBOutlet var gateNr: UILabel! //Gate文字
  @IBOutlet var departingFrom: UILabel! //出发地文字
  @IBOutlet var arrivingTo: UILabel! //目的地文字
  @IBOutlet var planeImage: UIImageView! //飞机图片
  
  @IBOutlet var flightStatus: UILabel! //状态文字
  @IBOutlet var statusBanner: UIImageView! //状态图片
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先我们进行图片的转场切换&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func fadeImageView(imageView: UIImageView, toImage: UIImage, showEffects: Bool) {

    UIView.transition(with: imageView, duration: 1.0, options: .transitionCrossDissolve,
      animations: {
        imageView.image = toImage
      },
      completion: nil
    )

    UIView.animate(withDuration: 1.0, delay: 0.0, options: .curveEaseOut,
      animations: {
        self.snowView.alpha = showEffects ? 1.0 : 0.0
      },
      completion: nil
    )
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;transitionCrossDissolve options枚举中的一个 交叉过度溶解&lt;/li&gt;
  &lt;li&gt;curveEaseOut options枚举中的一个 快进慢出 类似刹车&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接着我们来做立体转场的效果, 但这个并不是真正的立体效果, 而是通过两个View的动画进行模拟&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func cubeTransition(label: UILabel, text: String, direction: AnimationDirection) {

    let auxLabel = UILabel(frame: label.frame) //新建一个临时Label
    auxLabel.text = text
    auxLabel.font = label.font
    auxLabel.textAlignment = label.textAlignment
    auxLabel.textColor = label.textColor
    auxLabel.backgroundColor = label.backgroundColor

    let auxLabelOffset = CGFloat(direction.rawValue) * //设置偏移
      label.frame.size.height/2.0

    auxLabel.transform = CGAffineTransform(scaleX: 1.0, y: 0.1).concatenating( //这里的concatenating 类似于RxSwift的concat, 向后叠加.
      CGAffineTransform(translationX: 0.0, y: auxLabelOffset))

    label.superview!.addSubview(auxLabel) //添加View保持和Label平级

    UIView.animate(withDuration: 0.5, delay: 0.0, options: .curveEaseOut,
      animations: {
        auxLabel.transform = .identity //还原仿射
        label.transform =
          CGAffineTransform(scaleX: 1.0, y: 0.1).concatenating( //进行仿射缩放动画
          CGAffineTransform(translationX: 0.0, y: -auxLabelOffset)) //进行位移缩放动画
      },
      completion: {_ in
        label.text = auxLabel.text
        label.transform = .identity //还原仿射

        auxLabel.removeFromSuperview() //完成后删除临时Label
      }
    )
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;进行移动动画:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func moveLabel(label: UILabel, text: String, offset: CGPoint) {
    let auxLabel = UILabel(frame: label.frame) //同样新建一个临时Label
    auxLabel.text = text
    auxLabel.font = label.font
    auxLabel.textAlignment = label.textAlignment
    auxLabel.textColor = label.textColor
    auxLabel.backgroundColor = UIColor.clear

    auxLabel.transform = CGAffineTransform(translationX: offset.x, y: offset.y) //临时Label进行位移
    auxLabel.alpha = 0
    view.addSubview(auxLabel)

    UIView.animate(withDuration: 0.5, delay: 0.0, options: .curveEaseIn,
      animations: {
        label.transform = CGAffineTransform(translationX: offset.x, y: offset.y)
        label.alpha = 0.0
      },
      completion: nil
    )

    UIView.animate(withDuration: 0.25, delay: 0.1, options: .curveEaseIn,
      animations: {
        auxLabel.transform = .identity
        auxLabel.alpha = 1.0
      },
      completion: {_ in
        //clean up
        auxLabel.removeFromSuperview()
        label.text = text
        label.alpha = 1.0
        label.transform = .identity
      }
    )
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;curveEaseIn options枚举中的一个 慢进快出 类似加速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给飞机添加上关键帧动画&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func planeDepart() {
    let originalCenter = planeImage.center //保存飞机位置

    UIView.animateKeyframes(withDuration: 1.5, delay: 0.0, //进行关键帧动画
      animations: {
        //add keyframes
        UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 0.25, //添加关键帧
          animations: {
            self.planeImage.center.x += 80.0 //进行位移
            self.planeImage.center.y -= 10.0
          }
        )

        UIView.addKeyframe(withRelativeStartTime: 0.1, relativeDuration: 0.4) {
          self.planeImage.transform = CGAffineTransform(rotationAngle: -.pi / 8) //进行旋转
        }

        UIView.addKeyframe(withRelativeStartTime: 0.25, relativeDuration: 0.25) {
          self.planeImage.center.x += 100.0
          self.planeImage.center.y -= 50.0
          self.planeImage.alpha = 0.0 //淡出动画
        }

        UIView.addKeyframe(withRelativeStartTime: 0.51, relativeDuration: 0.01) {
          self.planeImage.transform = .identity //重置仿射动画
          self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y) //重置位置
        }

        UIView.addKeyframe(withRelativeStartTime: 0.55, relativeDuration: 0.45) {
          self.planeImage.alpha = 1.0 //淡入动画
          self.planeImage.center = originalCenter //回到原点
        }

      },
      completion: nil
    )
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后我们将所有动画放在一起&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func changeFlight(to data: FlightData, animated: Bool = false) {
    
    // populate the UI with the next flight's data
    if animated {
      planeDepart()
      summarySwitch(to: data.summary)

      fadeImageView(imageView: bgImageView,
                    toImage: UIImage(named: data.weatherImageName)!,
                    showEffects: data.showWeatherEffects)

      let direction: AnimationDirection = data.isTakingOff ?
        .positive : .negative

      cubeTransition(label: flightNr, text: data.flightNr,  direction: direction)
      cubeTransition(label: gateNr, text: data.gateNr,  direction: direction)

      let offsetDeparting = CGPoint( //设定偏移量
        x: CGFloat(direction.rawValue * 80),
        y: 0.0
      )

      moveLabel(label: departingFrom, text: data.departingFrom,
                offset: offsetDeparting)

      let offsetArriving = CGPoint( /设定偏移量
        x: 0.0,
        y: CGFloat(direction.rawValue * 50)
      )

      moveLabel(label: arrivingTo, text: data.arrivingTo,
                offset: offsetArriving)

      cubeTransition(label: flightStatus, text: data.flightStatus,  direction: direction)

    } else {
      bgImageView.image = UIImage(named: data.weatherImageName)
      snowView.isHidden = !data.showWeatherEffects
      flightNr.text = data.flightNr
      gateNr.text = data.gateNr
      departingFrom.text = data.departingFrom
      arrivingTo.text = data.arrivingTo

      flightStatus.text = data.flightStatus
      summary.text = data.summary
    }
    
    // schedule next flight
    delay(seconds: 3.0) { //3秒后进行递归调用.
      self.changeFlight(to: data.isTakingOff ? parisToRome : londonToParis, animated: true)
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;演示效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-6c5bcf96d89c86d8.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Apr 2017 11:58:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Animations-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8View%E7%9A%84%E5%8A%A8%E7%94%BB%E5%90%97/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Animations-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8View%E7%9A%84%E5%8A%A8%E7%94%BB%E5%90%97/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>RxSwift 函数式组合运算符实操</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上周我们开启了RxSwift的学习之旅, 从可观察序列–&amp;gt;过滤运算符–&amp;gt;映射运算符, 接下来我们来说说组合运算符. 说实话, 对于之前的内容的学习, 我觉得还是比较通俗易懂的, 但是这次的组合运算符相比之前在理解难易程度上又上了个档次, 本节我们就来攻克这一挑战吧! 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-a67b7f2ab21d4b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本节所需的一些关于组合的基本知识已经更新到&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;代码中的playground文件中, 没有接触过响应式编程的同学请和之前一样先行在&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift/blob/master/Our%20Planet/Our%20Planet.playground/Contents.swift&quot;&gt;playground&lt;/a&gt;中了解概要以便更好的理解本文. 本节我们就通过案例逐步精讲组合操作符在实际开发时的作用.&lt;/p&gt;

&lt;p&gt;这次的UI层面也不是特别复杂, 一个TableView的列表页和一个有Slider控制的TableView列表页: 
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-821df01cb8ecc097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本章是对于&lt;a href=&quot;http://www.jianshu.com/p/6b80a0db56bd&quot;&gt;RxSwift 响应式编程实战 映射运算符&lt;/a&gt;进行升级的一节, 所以我们接着网络请求这块讲起, 我们先将模型类(&lt;code class=&quot;highlighter-rouge&quot;&gt;EOCategory&lt;/code&gt; ` EOError&lt;code class=&quot;highlighter-rouge&quot;&gt; &lt;/code&gt; EOLocation&lt;code class=&quot;highlighter-rouge&quot;&gt; &lt;/code&gt; EOEvent`)添加到工程中.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fileprivate static let API = &quot;https://eonet.sci.gsfc.nasa.gov/api/v2.1&quot;
    static let categoriesEndpoint = &quot;/categories&quot;
    fileprivate static let eventsEndpoint = &quot;/events&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   fileprivate static func request(endpoint: String, query: [String : Any] = [:]) -&amp;gt; Observable&amp;lt;[String : Any]&amp;gt; {
    
        do {
            guard let url = URL(string: API)?.appendingPathComponent(endpoint), var components = URLComponents(url: url, resolvingAgainstBaseURL: true) else {
                throw EOError.invalidURL(endpoint)
            }
            
            components.queryItems = try query.flatMap { (key, value) in
                guard let v = value as? CustomStringConvertible else {
                    throw EOError.invalidParameter(key, value)
                }
                return URLQueryItem(name: key , value: v.description)
            }
            
            guard let finalURL = components.url else {
                throw EOError.invalidURL(endpoint)
            }
            
            let request = URLRequest(url: finalURL)
            return URLSession.shared.rx.response(request: request).map { _, data -&amp;gt; [String : Any] in
                guard let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []), let result = jsonObject as? [String : Any] else {
                    throw EOError.invalidJSON(finalURL.absoluteString)
                }
                return result
            }
        } catch {
            return Observable.empty()
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们从请求的函数开始讲起, 和之前不同的是, 这次我们将请求直接封装在模型里, 传统的MVC模式.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过对&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;接口进行校验得到可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;URLComponents&lt;/code&gt;, 如果url不可用抛出异常.&lt;/li&gt;
  &lt;li&gt;将参数赋值给&lt;code class=&quot;highlighter-rouge&quot;&gt;URLQueryItem&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;不符合规则抛出异常.&lt;/li&gt;
  &lt;li&gt;拿到最终的&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;, 如果拿不到抛出异常.&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;URLRequest&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;进行JSON序列化, 返回&lt;code class=&quot;highlighter-rouge&quot;&gt;(HTTPURLResponse, Data)&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;如果抛出异常则返回空的可观察序列.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static var categories: Observable&amp;lt;[EOCategory]&amp;gt; = {
        return EONET.request(endpoint: categoriesEndpoint)
            .map { data in
                let categories = data[&quot;categories&quot;] as? [[String: Any]] ?? []
                return categories
                    .flatMap(EOCategory.init)
                    .sorted { $0.name &amp;lt; $1.name }
            }
            .shareReplay(1)
    }()

    ...

    fileprivate static func events(forLast days: Int, closed: Bool, endpoint: String) -&amp;gt; Observable&amp;lt;[EOEvent]&amp;gt; {
        
        return request(endpoint: eventsEndpoint, query: [
            &quot;days&quot;: NSNumber(value: days),
            &quot;status&quot;: (closed ? &quot;closed&quot; : &quot;open&quot;)
        ]).map { json in
            guard let raw = json[&quot;events&quot;] as? [[String : Any]] else {
                throw EOError.invalidJSON(endpoint)
            }
            return raw.flatMap(EOEvent.init)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接着我们对categories的外部变量进行计算属性的get方法.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进行请求调用上面的请求并传入尾部节点.&lt;/li&gt;
  &lt;li&gt;进行排序并&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;EOCategory &lt;/code&gt;模型上.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shareReplay(1)&lt;/code&gt;将请求进行一次缓存, 下次调用订阅不再进行请求.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;events&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;categories&lt;/code&gt;相同, 进行请求映射.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static func events(forLast days: Int = 360) -&amp;gt; Observable&amp;lt;[EOEvent]&amp;gt; {
  let openEvents = events(forLast: days, closed: false)
  let closedEvents = events(forLast: days, closed: true)
  return openEvents.concat(closedEvents)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;closedEvents &lt;/code&gt;进行请求映射后的模型数组添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;openEvents&lt;/code&gt;之后.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static func events(forLast days: Int = 360, category: EOCategory) -&amp;gt; Observable&amp;lt;[EOEvent]&amp;gt; {

        let openEvents = events(forLast: days, closed: false, endpoint: category.endpoint)
        let closedEvents = events(forLast: days, closed: true, endpoint: category.endpoint)
        
        return Observable.of(openEvents, closedEvents).merge().reduce([]) { running, new in
            running + new
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;进行&lt;code class=&quot;highlighter-rouge&quot;&gt;marge&lt;/code&gt;, 用工&lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;的同学一定知道, 其效果和&lt;code class=&quot;highlighter-rouge&quot;&gt;concat&lt;/code&gt;类似.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func startDownload() {
        
        download.progress.progress = 0.0
        download.label.text = &quot;Download: 0%&quot;
        
        let eoCategories = EONET.categories
        let downloadedEvents = eoCategories.flatMap { categories in
            return Observable.from(categories.map { category in
                EONET.events(forLast: 360, category: category)
            })
            }.merge(maxConcurrent: 2)
        let updatedCategories = eoCategories.flatMap { categories in
            downloadedEvents.scan(categories) { updated, events in
                return updated.map { category in
                    let eventsForCategory = EONET.filteredEvents(events: events, forCategory: category)
                    if !eventsForCategory.isEmpty {
                        var cat = category
                        cat.events = cat.events + eventsForCategory
                        return cat
                    }
                    return category
                }
            }
        }
        eoCategories.concat(updatedCategories).bind(to: categories).addDisposableTo(disposeBag)
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段是我们本节的重头戏, 我们逐一来讲解下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eoCategories &lt;/code&gt;首先我们拿到请求到的数据&lt;code class=&quot;highlighter-rouge&quot;&gt;EONET.categories&lt;/code&gt; 属性观察get进行请求, 这个之前说过了.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;downloadedEvents &lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap &lt;/code&gt;映射转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt;合并后的每个相对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;EOEvent&lt;/code&gt;模型数组, 并发数设为2.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updatedCategories&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;映射进行对合并完的&lt;code class=&quot;highlighter-rouge&quot;&gt;downloadedEvents&lt;/code&gt;模型数组进行&lt;code class=&quot;highlighter-rouge&quot;&gt;scan&lt;/code&gt;扫描, 并重新组合新的&lt;code class=&quot;highlighter-rouge&quot;&gt;category&lt;/code&gt;内的&lt;code class=&quot;highlighter-rouge&quot;&gt;events&lt;/code&gt;模型数组.&lt;/li&gt;
  &lt;li&gt;最后将更新后的数据&lt;code class=&quot;highlighter-rouge&quot;&gt;concat&lt;/code&gt;添加并&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;绑定在&lt;code class=&quot;highlighter-rouge&quot;&gt;categories&lt;/code&gt;变量上就大功告成了.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        
        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;categoryCell&quot;)!

        let category = categories.value[indexPath.row]
        cell.textLabel?.text = &quot;\(category.name) (\(category.events.count))&quot;
        cell.accessoryType = (category.events.count &amp;gt; 0) ? .disclosureIndicator : .none
        return cell
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;categories即为上面请求映射过滤组合后绑定的变量, 通过对Cell的自定义 就能够得到下面请求的列表了.
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-de67226ed07f5b2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成了第一个页面, 我们开始着下一个页面: EventsViewController&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 60
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;进行Autolayout约束后, 我们可以在添加以下代码来代替之前复杂的cell高度的运算.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        events.asObservable().subscribe(onNext: { [weak self] _ in
            self?.tableView.reloadData()
        }).addDisposableTo(disposeBag)
        
        Observable.combineLatest(days.asObservable(), events.asObservable()) { (days, events) -&amp;gt; [EOEvent] in
            let maxInterval = TimeInterval(days * 24 * 3600)
            return events.filter { event in
                if let date = event.closeDate {
                    return abs(date.timeIntervalSinceNow) &amp;lt; maxInterval
                }
                return true
            }
        }.bind(to: filteredEvent).addDisposableTo(disposeBag)
    
        filteredEvent.asObservable().subscribe(onNext: { [weak self] _ in
            self?.tableView.reloadData()
        }).addDisposableTo(disposeBag)

        days.asObservable().subscribe(onNext: { [weak self] days in
            self?.daysLabel.text = &quot;Last \(days) days&quot;
        }).addDisposableTo(disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;events&lt;/code&gt;是从上个页面传递过来的变量, 类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;let events = Variable&amp;lt;[EOEvent]&amp;gt;([])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过对&lt;code class=&quot;highlighter-rouge&quot;&gt;events&lt;/code&gt;的作为可观察序列并进行订阅, 当可观察者被添加进订阅就进行列表的刷新.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable.combineLatest()&lt;/code&gt;对日期和时间做最后的绑定, 只保留可观察序列的最后的值的组合,并进行过滤绑定在&lt;code class=&quot;highlighter-rouge&quot;&gt;filteredEvent&lt;/code&gt;变量上, 类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;let filteredEvent = Variable&amp;lt;[EOEvent]&amp;gt;([])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接下来两行对于关注本系列的同学应该不用解释, 就是进行订阅并刷新UI.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @IBAction func sliderAction(_ sender: AnyObject) {
        days.value = Int(slider.value)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后对slider添加事件, 并改变days的值.接下来会触发一系列的订阅.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        days.asObservable().subscribe(onNext: { [weak self] days in
            self?.daysLabel.text = &quot;Last \(days) days&quot;
        }).addDisposableTo(disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;触发上面的订阅并进行&lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;的UI刷新&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Observable.combineLatest(days.asObservable(), events.asObservable()) { (days, events) -&amp;gt; [EOEvent] in
            let maxInterval = TimeInterval(days * 24 * 3600)
            return events.filter { event in
                if let date = event.closeDate {
                    return abs(date.timeIntervalSinceNow) &amp;lt; maxInterval
                }
                return true
            }
        }.bind(to: filteredEvent).addDisposableTo(disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;触发&lt;code class=&quot;highlighter-rouge&quot;&gt;combineLatest&lt;/code&gt;最新组合运算符, 并重新进行过滤绑定.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        events.asObservable().subscribe(onNext: { [weak self] _ in
            self?.tableView.reloadData()
        }).addDisposableTo(disposeBag)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;在对&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;过滤的过程中触发订阅进行列表刷新.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        filteredEvent.asObservable().subscribe(onNext: { [weak self] _ in
            self?.tableView.reloadData()
        }).addDisposableTo(disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;在过滤完成重新绑定后, 触发订阅进行最后的刷新.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文因为篇幅所限, 仅保留一些核心的代码, 并对核心代码进行逐条讲解, 需要详细了解, 请去github下载源码后对照阅读. 通过对于可观察序列, 过滤, 映射, 组合的理解和实战, 通过一个事件的改变异步触发订阅的响应式编程的思想, 我们应该已经能算入门了.&lt;/p&gt;

&lt;p&gt;演示效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-c95ba5ed107bd458.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 14:51:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>RxSwift 函数式映射运算符实操</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一路走来, 感觉RxSwift也不像之前一样晦涩难懂了, 甚至渐渐的喜欢上了这种响应式编程的思想, 将对象作为可观察对象并进行订阅, 加上过滤操作符的协作, 一切的逻辑运算都在后台线程执行, 本节所要讲的是Rx中最为强大的功能 — 映射, 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-a67b7f2ab21d4b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本节所需的一些关于映射的基本知识已经更新到&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;代码中的playground文件中, 没有接触过响应式编程的同学请和之前一样先行在&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift/blob/master/GitHubRepo/GitHubRepository/GitHubRepository.playground/Contents.swift&quot;&gt;playground&lt;/a&gt;中了解概要以便更好的理解本文. 本节我们就通过案例逐步精讲映射操作符在网络请求时的妙用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-81e919722e1627dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这次的UI界面非常的简单,  就是一个简单的TableViewController, 我们通过网络请求将获取的JSON数据映射到Model上并展示在Cell上, API: https://api.github.com/repos/coderZsq/coderZsq.target.swift/events&lt;/p&gt;

&lt;p&gt;想了解如何进行后台搭建并模拟数据返回的同学 请点击 –&amp;gt; &lt;a href=&quot;http://www.jianshu.com/p/5a03995a6ce1&quot;&gt;Hybird 实现热修复架构 从MVC说起&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;5715074941&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PushEvent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;actor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;19483268&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;coderZsq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;display_login&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;coderZsq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;gravatar_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://api.github.com/users/coderZsq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://avatars.githubusercontent.com/u/19483268?&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;repo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;87806175&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;coderZsq/coderZsq.target.swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://api.github.com/repos/coderZsq/coderZsq.target.swift&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;payload&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;push_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1688506435&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;distinct_size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;ref&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;refs/heads/master&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;head&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;90306f546ee0e17d94891415a2f8938d28736dc7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;before&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;778ac2b60b85a3e97e0a1e85e16cdb1061445181&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;commits&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sha&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;90306f546ee0e17d94891415a2f8938d28736dc7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a13701777868@yahoo.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Castie!&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Update README.md&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;distinct&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://api.github.com/repos/coderZsq/coderZsq.target.swift/commits/90306f546ee0e17d94891415a2f8938d28736dc7&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;public&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2017-04-19T12:12:49Z&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们先从浏览器看下接口所返回的字段, 并提取我们需要的字段生成模型Model, 以备之后的映射.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typealias AnyDict = [String: Any]

class Event {

    let repo: String
    let name: String
    let imageUrl: URL
    let action: String
    
    init?(dictionary: AnyDict) {
        guard let repoDict = dictionary[&quot;repo&quot;] as? AnyDict,
            let actor = dictionary[&quot;actor&quot;] as? AnyDict,
            let repoName = repoDict[&quot;name&quot;] as? String,
            let actorName = actor[&quot;display_login&quot;] as? String,
            let actorUrlString = actor[&quot;avatar_url&quot;] as? String,
            let actorUrl  = URL(string: actorUrlString),
            let actionType = dictionary[&quot;type&quot;] as? String
            else {  return nil  }
        
        repo = repoName
        name = actorName
        imageUrl = actorUrl
        action = actionType
    }
    
    var dictionary: AnyDict {
        return [
            &quot;repo&quot; : [&quot;name&quot;: repo],
            &quot;actor&quot;: [&quot;display_login&quot;: name, &quot;avatar_url&quot;: imageUrl.absoluteString],
            &quot;type&quot; : action
        ]
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们将模型命名为Event, 添加了一个dictionary变量供返回序列化完成后的字典.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func fetchEvents(repo: String) {
        
        let response = Observable.from([repo]).map { urlString -&amp;gt; URL in
                return URL(string: &quot;https://api.github.com/repos/\(urlString)/events&quot;)!
            }.map { [weak self] url -&amp;gt; URLRequest in
                var request = URLRequest(url: url)
                if let modifiedHeader = self?.lastModified.value {
                    request.addValue(modifiedHeader as String,forHTTPHeaderField: &quot;Last-Modified&quot;)
                }
                return request
            }.flatMap { request -&amp;gt; Observable&amp;lt;(HTTPURLResponse, Data)&amp;gt; in
                return URLSession.shared.rx.response(request: request)
            }.shareReplay(1)
        
        response.filter { response, _ in
                return 200..&amp;lt;300 ~= response.statusCode
            }.map { _, data -&amp;gt; [[String: Any]] in
                guard let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []),
                    let result = jsonObject as? [[String: Any]] else { return [] }
                return result
            }.filter { objects in
                return objects.count &amp;gt; 0
            }.map { objects in
                return objects.flatMap(Event.init)
            }.subscribe(onNext: { [weak self] newEvents in
                self?.processEvents(newEvents)
            }).addDisposableTo(bag)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;一切准备就绪, 我们就来说说本节最重要的部分了, 我们逐行来进行讲解.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable.from()&lt;/code&gt;的方式创建一个可观察对象, 传入&lt;code class=&quot;highlighter-rouge&quot;&gt;repo&lt;/code&gt;字段, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;映射成&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;返回.&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;映射将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;映射成&lt;code class=&quot;highlighter-rouge&quot;&gt;URLRequest&lt;/code&gt;, 如果有进行修改则写入请求头.&lt;/li&gt;
  &lt;li&gt;通过’flatmap’映射将将&lt;code class=&quot;highlighter-rouge&quot;&gt;URLRequest&lt;/code&gt;映射成&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTPURLResponse &lt;/code&gt;, 网络请求封装在&lt;code class=&quot;highlighter-rouge&quot;&gt;RxCocoa&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;URLSession.shared.rx.response(request:)&lt;/code&gt;方法中, 有兴趣的同学可以看下源码, 当然这些都是在后台线程中执行的.&lt;/li&gt;
  &lt;li&gt;最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;shareReplay(1)&lt;/code&gt;进行订阅共享. &lt;code class=&quot;highlighter-rouge&quot;&gt;shareReplay&lt;/code&gt;可以将之前响应结果加入缓冲区. 这也是不使用&lt;code class=&quot;highlighter-rouge&quot;&gt;share()&lt;/code&gt;的原因, 避免多次请求.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于flatmap 和 map 之前的区别不了解的同学可以看下&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift/blob/master/GitHubRepo/GitHubRepository/GitHubRepository.playground/Contents.swift&quot;&gt;playground&lt;/a&gt;中的例子, 或者直接查看Swift中的Array文档.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]
    /// 
    ///     let mapped: [Int?] = numbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    /// 
    ///     let flatMapped: [Int] = numbers.flatMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    public func flatMap&amp;lt;ElementOfResult&amp;gt;(_ transform: (Element) throws -&amp;gt; ElementOfResult?) rethrows -&amp;gt; [ElementOfResult]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;拿到了响应结果, 我们对相应结果进行过滤, 如果对过滤不了解的同学, 请翻看之前的文章 –&amp;gt; &lt;a href=&quot;http://www.jianshu.com/p/04349d324a6f&quot;&gt;RxSwift 响应式编程实战 过滤运算符&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;filter &lt;/code&gt;过滤掉错误的statusCode, 对于statusCode不了解的同学可以查阅HTTP状态码的资料, &lt;code class=&quot;highlighter-rouge&quot;&gt;~=&lt;/code&gt;操作符是指操作符右边的值是否在操作符左边的范围之内, 返回Bool类型,&lt;/li&gt;
  &lt;li&gt;得到正确的数据后, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;进行映射将数据映射成字典数组类型, 使用的是系统的JSON序列化.&lt;/li&gt;
  &lt;li&gt;再次进行&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;过滤, 过滤掉没有返回的数据.&lt;/li&gt;
  &lt;li&gt;再次进行&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;映射, 将数据结构映射到Event模型中.&lt;/li&gt;
  &lt;li&gt;最后进行订阅执行操作并添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;DisposeBag&lt;/code&gt;中.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接着我们来看下拿到了映射完成后的[Event]模型数组后的执行操作.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func processEvents(_ newEvents: [Event]) {
        
        var updatedEvents = newEvents + events.value
        if updatedEvents.count &amp;gt; 50 {
            updatedEvents = Array&amp;lt;Event&amp;gt;(updatedEvents.prefix(upTo: 50))
        }
        
        events.value = updatedEvents
        tableView.reloadData()
        refreshControl?.endRefreshing()
        
        let eventsArray = updatedEvents.map{ $0.dictionary } as NSArray
        eventsArray.write(to: eventsFileURL, atomically: true)
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;拿到模型数组的个数后取如果超过50个, 取前面50个数据.&lt;/li&gt;
  &lt;li&gt;刷新tableView, refreshControl结束刷新, 并将映射模型缓存到沙盒.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func cachedFileURL(_ fileName: String) -&amp;gt; URL {
    return FileManager.default.urls(for: .cachesDirectory, in: .allDomainsMask).first!.appendingPathComponent(fileName)
}

class ViewController: UITableViewController {

    fileprivate let repo = &quot;coderZsq/coderZsq.target.swift&quot;
    fileprivate let events = Variable&amp;lt;[Event]&amp;gt;([])
    fileprivate let bag = DisposeBag()
    
    fileprivate let eventsFileURL = cachedFileURL(&quot;events.plist&quot;)
    fileprivate let modifiedFileURL = cachedFileURL(&quot;modified.txt&quot;)
    fileprivate let lastModified = Variable&amp;lt;NSString?&amp;gt;(nil)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        title = repo
        
        let eventsArray = (NSArray(contentsOf: eventsFileURL)
            as? [[String: Any]]) ?? []
        events.value = eventsArray.flatMap(Event.init)
        lastModified.value = try? NSString(contentsOf: modifiedFileURL, usedEncoding: nil)
        
        setupRefreshControl()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cachedFileURL&lt;/code&gt;缓存路径地址&lt;/li&gt;
  &lt;li&gt;每次先执行缓存本地的映射数据再进行网络请求.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;映射和过滤的好处在于一切都在后台线程进行, 并在映射和过滤的过程中如果发生不匹配的情况, 之后的操作就会被打断, 不再执行.&lt;/p&gt;

&lt;p&gt;演示效果:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-86d2e2011251ccd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Apr 2017 10:45:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%98%A0%E5%B0%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%98%A0%E5%B0%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>RxSwift 函数式过滤运算符实操</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;接着上一部分, 我们已经完成了函数式编程的简单实践, 也同时接触了&lt;code class=&quot;highlighter-rouge&quot;&gt;Photos&lt;/code&gt;框架带来的自定义的便利, 主要熟悉了&lt;code class=&quot;highlighter-rouge&quot;&gt;Variable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Subject&lt;/code&gt; 作为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt; 进行订阅 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt; 并通过处置包&lt;code class=&quot;highlighter-rouge&quot;&gt;DisposeBag&lt;/code&gt; 处理的具体案例, 这一节我们来进一步完善相片拼图. 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-a67b7f2ab21d4b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本节所需的一些关于订阅信息过滤的基本知识已经更新到&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;代码中的playground文件中, 没有接触过响应式编程的同学请和之前一样先行在&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift/blob/master/AlbumPuzzle/AlbumPuzzle.playground/Contents.swift&quot;&gt;playground&lt;/a&gt;中了解概要以便更好的理解本文. 在进行对项目的完善之前我们先来看一个问题:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example(of: &quot;Sharing subscription&quot;) {
    
    var start = 0
    func getStartNumber() -&amp;gt; Int {
        start += 1
        return start
    }
    
    let numbers = Observable&amp;lt;Int&amp;gt;.create { observer in
        
        let start = getStartNumber()
        observer.onNext(start)
        observer.onNext(start+1)
        observer.onNext(start+2)
        observer.onCompleted()
        return Disposables.create()
    }
    
    numbers.subscribe(
        onNext: { el in
            print(&quot;element [\(el)]&quot;)
        },
        onCompleted: {
            print(&quot;---------------&quot;)
        }
    )
    
    numbers.subscribe(
        onNext: { el in
            print(&quot;element [\(el)]&quot;)
        },
        onCompleted: {
            print(&quot;---------------&quot;)
        }
    )
}

---Example of: Sharing subscription ---
element [1]
element [2]
element [3]
---------------
element [2]
element [3]
element [4]
---------------

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;同样是对于可观察对象进行订阅为什么会出现两种不同的结果? 问题是，每次调用subscribe（…）时，都会为该订阅创建一个新的Observable，并且每个副本不能保证与之前的相同。 即使Observable确实产生了相同的元素序列，为每个订阅生成相同的重复元素也是没有意义的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example(of: &quot;Sharing subscription Fix&quot;) {
        
    var start = 0
    func getStartNumber() -&amp;gt; Int {
        start += 1
        return start
    }
    
    let numbers = Observable&amp;lt;Int&amp;gt;.create { observer in
        
        let start = getStartNumber()
        observer.onNext(start)
        observer.onNext(start+1)
        observer.onNext(start+2)
        observer.onCompleted()
        return Disposables.create()
    }
    
    let shareNumbers = numbers.share()
    
    shareNumbers.subscribe(
        onNext: { el in
            print(&quot;element [\(el)]&quot;)
        },
        onCompleted: {
            print(&quot;---------------&quot;)
        }
    )
    
    shareNumbers.subscribe(
        onNext: { el in
            print(&quot;element [\(el)]&quot;)
        },
        onCompleted: {
            print(&quot;---------------&quot;)
        }
    )
}

---Example of: Sharing subscription Fix ---
element [1]
element [2]
element [3]
---------------
---------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果需要进行共享订阅，可以使用share（）运算符。 Rx代码中的常见模式是通过过滤每个结果中的不同元素来从同一个源中创建几个序列。&lt;/p&gt;

&lt;p&gt;回到我们的项目中来看如何将share()运算符运用的实际, 将ViewController中的代码修改如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController {
    ...
    fileprivate var imageCache = [Int]() //update
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //update
    fileprivate func updateNavigationIcon() {
        let icon = imagePreview.image?.scaled(CGSize(width: 22, height: 22)).withRenderingMode(.alwaysOriginal)
        navigationItem.leftBarButtonItem = UIBarButtonItem(image: icon, style: .done, target: nil, action: nil)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @IBAction func actionAdd() {
//        images.value.append(UIImage(named: &quot;Castie!&quot;)!)
        
        let albumViewController = storyboard?.instantiateViewController(withIdentifier: &quot;AlbumViewController&quot;) as! AlbumViewController
        
        //update
        let newImages = albumViewController.selectedImages.share()

        newImages.takeWhile { [weak self] image in
                return (self?.images.value.count ?? 0) &amp;lt; 6
            }.filter { newImage in
                return newImage.size.width &amp;gt; newImage.size.height
            }.filter { [weak self] newImage in
                let len = UIImagePNGRepresentation(newImage)?.count ?? 0
                guard self?.imageCache.contains(len) == false else { return false }
                self?.imageCache.append(len)
                return true
            }.subscribe(
                
            onNext: { [weak self] newImage in
                guard let images = self?.images else { return }
                images.value.append(newImage)
            },
            onDisposed: {
                print(&quot;completed photo selection&quot;)
            }
                
        ).addDisposableTo(albumViewController.bag)
        
        newImages.ignoreElements().subscribe(
            onCompleted: { [weak self] in
            self?.updateNavigationIcon()
        }).addDisposableTo(albumViewController.bag)
        
        navigationController?.pushViewController(albumViewController, animated: true)
    }
    
    @IBAction func actionClear() {
        images.value = []
        //update
        imageCache = []
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们来具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;actionAdd()&lt;/code&gt; 这段代码, 首先, 我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;share()&lt;/code&gt;操作符对可观察对象进行订阅共享&lt;code class=&quot;highlighter-rouge&quot;&gt;takeWhile()&lt;/code&gt;操作符将得到的订阅信息进行过滤, 返回最大六张图片和之前对点击按钮的屏蔽逻辑进行了对应, &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;操作符就是传统的函数式过滤, 返回图片宽度大于高度的图片及通过图片字节数和缓存池中的字节数判断是否为同一张图片. 这里我们新加了一个订阅 &lt;code class=&quot;highlighter-rouge&quot;&gt;ignoreElements()&lt;/code&gt; 操作符是忽略所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;onNext()&lt;/code&gt;事件, 只接收&lt;code class=&quot;highlighter-rouge&quot;&gt;onCompleted ()&lt;/code&gt;事件. UI层面我们在左上角添加了一个对应图片的缩略图.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //update
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        selectedImagesSubject.onCompleted()
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接下来我们就需要对AlbumViewController生命周期结束的时候对可观察对象进行&lt;code class=&quot;highlighter-rouge&quot;&gt;onCompleted()&lt;/code&gt;调用, 执行之前的订阅代码修改UI.
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-718f23f9c824c8bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行成功后, 我们顺利的看到左上角的缩略图显示了, 并且不能重复添加大于六张图片及只允许宽度大于长度的图片. 但我们这里有一个小问题, 当我们第一次访问相册的时候, 会弹出一个提示框对用户行为进行授权, 但授权完成后, 图片并没有显示出来, 这是因为懒加载的时候在授权验证前并没有拿到任何的数据. 我们来看看如何解决. 我们新建一个文件, 并对PHPhotoLibrary进行类扩展.&lt;/p&gt;

&lt;p&gt;PHPhotoLibrary可以看成是一个用户图库，包含了一些的图片和相册，同时包含本地的和iCloud中的资源。当Photos app发生图片的修改、增加、删除等改变时，使用PHPhotoLibrary来做一些刷新UI，保存数据等响应动作，同时也可以注册观察者（使用registerChangeObserver方法），当Photos app内容发生改变的时，会触发代理方法photoLibraryDidChange。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension PHPhotoLibrary {

    static var authorized: Observable&amp;lt;Bool&amp;gt; {
        return Observable.create { observer in

            DispatchQueue.main.async {
                if authorizationStatus() == .authorized {
                    observer.onNext(true)
                    observer.onCompleted()
                } else {
                    observer.onNext(false)
                    requestAuthorization { newStatus in
                        observer.onNext(newStatus == .authorized)
                        observer.onCompleted()
                    }
                }
            }
            
            return Disposables.create()
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里对于刚学习Swift的同学可能并不是很好理解, 这里我们对&lt;code class=&quot;highlighter-rouge&quot;&gt;PHPhotoLibrary&lt;/code&gt;扩展了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;authorized&lt;/code&gt;属性, 并通过计算属性返回了一个可观察对象, 对观察对象进行授权校验, 如果校验过就执行操作, 没有校验过就请求授权校验, 这里开了一个GCD的主线程, 但一般来说在订阅中是观察器不应该阻止当前线程. 接下来我们在AlbumViewController中进行使用.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override func viewDidLoad() {
        super.viewDidLoad()
        self.collectionView!.register(UICollectionViewCell.self, forCellWithReuseIdentifier: reuseIdentifier)
        //update
        let authorized = PHPhotoLibrary.authorized.share()
        
        authorized.skipWhile { $0 == false }.take(1).subscribe(onNext: { [weak self] _ in
            self?.images = AlbumViewController.loadImages()
            DispatchQueue.main.async {
                self?.collectionView?.reloadData()
            }
        }).addDisposableTo(bag)
        
        authorized.skip(1).takeLast(1).filter { $0 == false }.subscribe(onNext: { [weak self] _ in
            guard let errorMessage = self?.errorMessage else { return }
                DispatchQueue.main.async(execute: errorMessage)
        }).addDisposableTo(bag)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们通过订阅共享的形式进行, 第一个订阅授权验证当验证成功后进行获取系统相册图片, 并在主线程刷新UI, 第二个是发起请求验证后仍没有验证后, 主线程执行错误提示弹窗. 代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;skipWhile()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;take()&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;skip()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;takeLast()&lt;/code&gt;操作符, 不理解的同学可以到项目中的playground中先行了解.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fileprivate func errorMessage() {
        alert(title: &quot;No access to Camera Roll&quot;,
              text: &quot;You can grant access to Combinestagram from the Settings app&quot;)
            .take(5.0, scheduler: MainScheduler.instance)
            .subscribe(onDisposed: { [weak self] in
                self?.dismiss(animated: true, completion: nil)
                _ = self?.navigationController?.popViewController(animated: true)
        }).addDisposableTo(bag)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;errorMessage()&lt;/code&gt; 中需要讲一下的是&lt;code class=&quot;highlighter-rouge&quot;&gt;.take(5.0, scheduler: MainScheduler.instance)&lt;/code&gt; 从给定时间段的源序列中获取元素。 一旦时间间隔过去，完成结果序列。我们在ViewController中也更改如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fileprivate func setupObservable() {
        //update
        images.asObservable().throttle(0.5, scheduler: MainScheduler.instance).subscribe(onNext: { [weak self] images in
            guard let preview = self?.imagePreview else { return }
            preview.image = UIImage.collage(images: images, size: preview.frame.size)
            }).addDisposableTo(bag)
        
        images.asObservable().subscribe(onNext: { [weak self] images in
            self?.updateUI(images: images)
        }).addDisposableTo(bag)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.throttle(0.5, scheduler: MainScheduler.instance)&lt;/code&gt;和刚才的&lt;code class=&quot;highlighter-rouge&quot;&gt;take(_:scheduler:)&lt;/code&gt;非常相似, 是在一定时间间隔内过滤掉之前的元素只留下最新的元素,&lt;/p&gt;

&lt;p&gt;演示效果:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-c9e974553e6ba09b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Apr 2017 11:50:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%BF%87%E6%BB%A4%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/RxSwift-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%BF%87%E6%BB%A4%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%93%8D/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>RxSwift 大神们都在看的响应式</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上个系列的架构设计, 从MVC -&amp;gt; MVVM -&amp;gt; MVP -&amp;gt; Router -&amp;gt; Downgradable, 我们实现了通过分层将各个组件进行解耦并动态的升降级页面, 这一系列准备说说如何通过RxSwift进行响应式编程更好的和架构设计进行协同. 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-a67b7f2ab21d4b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这系列所述案例是通过Ray家的RxSwift一书进行笔记, 在学习本篇之前, 请确保熟练掌握Swift3基础语法并具备中级iOS开发能力. 对于RxSwift的概念不是很清晰的同学可以参照本文代码中的&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift/blob/master/AlbumPuzzle/AlbumPuzzle.playground/Contents.swift&quot;&gt;playground&lt;/a&gt;事先熟悉, 不理解的请先查阅概要, 以便更好的了解本文.&lt;/p&gt;

&lt;p&gt;首先我们需要通过cocapods进行引入RxSwift:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Uncomment the next line to define a global platform for your project
platform :ios, '10.0'

target 'AlbumPuzzle' do
    # Comment the next line if you're not using Swift and don't want to use dynamic frameworks
    use_frameworks!
    
    # Pods for AlbumPuzzle
    pod 'RxSwift',    '~&amp;gt; 3.2'
    pod 'RxCocoa',    '~&amp;gt; 3.2'
    
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-46cac43c61b71c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要添加一些必要的控件, 避免代码过多, 我们就通过StoryBoard来进行View层的布局, 第一个页面中我们需要四个控件: 展示图片, 添加按钮, 清除按钮, 保存按钮. 第二个页面就是个简单的CollectoinViewController.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController {
    
    @IBOutlet weak var imagePreview: UIImageView!
    @IBOutlet weak var buttonClear: UIButton!
    @IBOutlet weak var buttonSave: UIButton!
    @IBOutlet weak var itemAdd: UIBarButtonItem!
    
    fileprivate let bag = DisposeBag()
    fileprivate let images = Variable&amp;lt;[UIImage]&amp;gt;([])
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupObservable()
    }
}

extension ViewController {
    
    fileprivate func setupObservable() {
        
        images.asObservable().subscribe(onNext: { [weak self] images in
            guard let preview = self?.imagePreview else { return }
            preview.image = UIImage.collage(images: images, size: preview.frame.size)
        }).addDisposableTo(bag)
        
        images.asObservable().subscribe(onNext: { [weak self] images in
            self?.updateUI(images: images)
        }).addDisposableTo(bag)
    }
    
    fileprivate func updateUI(images: [UIImage]) {
        buttonSave.isEnabled = images.count &amp;gt; 0 &amp;amp;&amp;amp; images.count % 2 == 0
        buttonClear.isEnabled = images.count &amp;gt; 0
        itemAdd.isEnabled = images.count &amp;lt; 6
        title = images.count &amp;gt; 0 ? &quot;\(images.count) photos&quot; : &quot;Collage&quot;
    }
}


extension ViewController {
    
    @IBAction func actionAdd() {
        images.value.append(UIImage(named: &quot;Castie!&quot;)!)
    }
    
    @IBAction func actionClear() {
        images.value = []
    }
    
    @IBAction func actionSave() {
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们进入ViewController, 创建两个私有变量, bag, 是一个DisposeBag实例, images是一个Variable的泛型 &lt;code class=&quot;highlighter-rouge&quot;&gt;对于DisposeBag和Variable不了解的同学请事先查阅playground中的内容&lt;/code&gt; , 通过extension的语法&lt;code class=&quot;highlighter-rouge&quot;&gt; Swift的装饰模式 &lt;/code&gt;进行代码分区,  通过对images添加订阅监听images数组发生的变化, 并对按钮点击进行操作. 为了实现更好的效果, 需要引入UIImage+Collage分类.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-6a3d4c76e8003a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就简单的实现了响应式编程, 当订阅者的值被改变的时候, 就会更新操作. 就和KVO的监听效果相似. 由于iOS10开始对于访问用户信息的机制有所更新, 本例中需要访问用户相册, 所以在info.plist进行如下配置:
Privacy - Photo Library Usage Description, We need access to your device’s photo library to allow you to select photos for your collage.&lt;/p&gt;

&lt;p&gt;进行配置完成, 我们就通过Photos系统框架来进行对系统相册中的图片进行获取, 当然你也可以使用UIImagePickerController, 预知如何使用请&lt;a href=&quot;http://www.jianshu.com/p/555786f35357&quot;&gt;点击&lt;/a&gt;!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit
import Photos
import RxSwift

private let reuseIdentifier = &quot;Cell&quot;

class AlbumViewController: UICollectionViewController {
    
    let bag = DisposeBag()
    var selectedImages: Observable&amp;lt;UIImage&amp;gt; {
        return selectedImagesSubject.asObservable()
    }
    
    fileprivate let selectedImagesSubject = PublishSubject&amp;lt;UIImage&amp;gt;()
    fileprivate lazy var images = AlbumViewController.loadImages()
    fileprivate lazy var imageManager = PHCachingImageManager()
    fileprivate lazy var thumbnailSize: CGSize = {
        let cellSize = (self.collectionViewLayout as! UICollectionViewFlowLayout).itemSize
        return CGSize(width: cellSize.width * UIScreen.main.scale,
                      height: cellSize.height * UIScreen.main.scale)
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.collectionView!.register(UICollectionViewCell.self, forCellWithReuseIdentifier: reuseIdentifier)
    }
}

extension AlbumViewController {
    
    static func loadImages() -&amp;gt; PHFetchResult&amp;lt;PHAsset&amp;gt; {
        let allImagesOptions = PHFetchOptions()
        allImagesOptions.sortDescriptors = [NSSortDescriptor(key: &quot;creationDate&quot;, ascending: true)]
        return PHAsset.fetchAssets(with: allImagesOptions)
    }
}

extension AlbumViewController {
    
    override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&amp;gt; Int {
        return images.count
    }
    
    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&amp;gt; UICollectionViewCell {
        
        let asset = images.object(at: indexPath.item)
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: reuseIdentifier, for: indexPath)
        imageManager.requestImage(for: asset, targetSize: thumbnailSize, contentMode: .aspectFill, options: nil, resultHandler: { image, _ in
            cell.layer.contents = image?.cgImage
        })
        return cell
    }
    
    override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        
        let asset = images.object(at: indexPath.item)

        if let cell = collectionView.cellForItem(at: indexPath) {
            cell.alpha = 0
            UIView.animate(withDuration: 0.5, animations: {
                cell.alpha = 1
            })
        }

        imageManager.requestImage(for: asset, targetSize: view.frame.size, contentMode: .aspectFill, options: nil, resultHandler: { [weak self] image, info in
            guard let image = image, let info = info else { return }
            
            if let isThumbnail = info[PHImageResultIsDegradedKey as NSString] as? Bool, !isThumbnail {
                self?.selectedImagesSubject.onNext(image)
            }
        })
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里简要的说下Photos这个系统框架, Photos framework是iOS8苹果提供的新的图片框架，能直接获取图片和视频，包括iCloud上面的图库。使用这个框架可以获取assets来展示和回放，编辑图片或者视频内容，或者使用系统相册、时刻、和分享到iCloud的相册来进行相关操作.&lt;/p&gt;

&lt;p&gt;我们这里用到的有&lt;code class=&quot;highlighter-rouge&quot;&gt;PHCachingImageManager&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHFetchResult&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHFetchOptions&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHAsset&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PHCachingImageManager是PHImageManager的子类，如果相册中有大量的图片，而你的需求是要快速的获取这些图片的缩略图和大图数据用于展示，这个时候可以用PHCachingImageManager来实现，它具有缓存机制可以快速获取一个图册的缩略图，或者在后台请求全尺寸图片以便于快速展示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 *  会多次调用'resultHandler'，第一次调用，返回的图片清晰度较低，
 *  当高清晰度图片可以获取时,会再次调用，如果高质量的图片在缓存汇中，只调用一次'resultHandler'。
 *  这个方法默认是异步的，当从后台线程调用这个方法时，需要将options的'synchronous'设为YES.
 *
 *  @param asset         保存图片信息的asset
 *  @param targetSize    返回的图片尺寸
 *  @param contentMode   返回的图片显示模式
 *  @param options       image request option
 *  @param resultHandler 返回的内容
 *
 *  @return 请求标示，用于取消请求*/
    open func requestImage(for asset: PHAsset, targetSize: CGSize, contentMode: PHImageContentMode, options: PHImageRequestOptions?, resultHandler: @escaping (UIImage?, [AnyHashable : Any]?) -&amp;gt; Swift.Void) -&amp;gt; PHImageRequestID
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PHFetchResult是有序的photo实体对象的容器，包含通过给定的检索条件返回的asset，相册，一个相册类型中的所有相册列表（例如，smart album类型下的所有相册，它是有序的），在PHAsset,PHCollection,PHAssetcollection,PHCollectionList这几个类中都包含有相应的类方法包含对应信息的PHFetchRequest对象,例如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    open class func fetchAssets(with options: PHFetchOptions?) -&amp;gt; PHFetchResult&amp;lt;PHAsset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PHFetchOptions: 当你使用没方法获取PHAsset（图片和视频）,PHCollection（相册类型）,PHAssetCollection（相册）的实体（相当于包含多个数据的模型）使用PHFetchOptions对象指定操作，例如获取的实体的排列属性等。&lt;/p&gt;

&lt;p&gt;这里的操作很简单, 就是通过访问特定选项的PHFetchOptions得到PHFetchResult中的PHAsset并使用PHCachingImageManager请求系统相册得到相应的图片并通过寄宿图的方式展示到Cell上.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-425a3b6c535f638d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;响应式编程的关键我们在Cell点击的函数中的以下代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if let isThumbnail = info[PHImageResultIsDegradedKey as NSString] as? Bool, !isThumbnail {
       self?.selectedImagesSubject.onNext(image)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过发布对象PublishSubject的onNext方法将数据发送给订阅者, 回到ViewController, 我们对部分代码进行更新:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @IBAction func actionAdd() {
//        images.value.append(UIImage(named: &quot;Castie!&quot;)!)
        
        let albumViewController = storyboard?.instantiateViewController(withIdentifier: &quot;AlbumViewController&quot;) as! AlbumViewController
        
        albumViewController.selectedImages.subscribe(
            onNext: { [weak self] newImage in
                guard let images = self?.images else { return }
                images.value.append(newImage)
            },
            onDisposed: {
                print(&quot;completed photo selection&quot;)
            }
        ).addDisposableTo(albumViewController.bag)
        
        navigationController?.pushViewController(albumViewController, animated: true)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就通过RxSwift实现了页面之间的响应式交互, 接下来我们来实现图片的保存操作:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class AlbumWriter: NSObject {
    
    typealias Callback = (NSError?)-&amp;gt;Void
    
    private var callback: Callback
    private init(callback: @escaping Callback) {
        self.callback = callback
    }
    
    func image(_ image: UIImage, didFinishSavingWithError error: NSError?, contextInfo: UnsafeRawPointer) {
        callback(error)
    }
    
    static func save(_ image: UIImage) -&amp;gt; Observable&amp;lt;Void&amp;gt; {
        return Observable.create({ observer in
            let writer = AlbumWriter(callback: { error in
                if let error = error {
                    observer.onError(error)
                } else {
                    observer.onCompleted()
                }
            })
            UIImageWriteToSavedPhotosAlbum(image, writer, #selector(AlbumWriter.image(_:didFinishSavingWithError:contextInfo:)), nil)
            return Disposables.create()
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;封装一个图片储存的AlbumWriter类, 通过Create方法来创建观察者.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@IBAction func actionSave() {
        
        guard let image = imagePreview.image else { return }
        
        AlbumWriter.save(image).subscribe(
            
            onError: { [weak self] error in
            self?.showMessage(&quot;Error&quot;, description: error.localizedDescription)
            
            }, onCompleted: { [weak self] in
                self?.showMessage(&quot;Saved&quot;)
                self?.actionClear()
            }
            
        ).addDisposableTo(bag)
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后在Save操作的时候进行订阅就大功告成了!!&lt;/p&gt;

&lt;p&gt;演示效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-9b240f1eb5dac87a.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 12:13:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/RxSwift-%E5%A4%A7%E7%A5%9E%E4%BB%AC%E9%83%BD%E5%9C%A8%E7%9C%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/RxSwift-%E5%A4%A7%E7%A5%9E%E4%BB%AC%E9%83%BD%E5%9C%A8%E7%9C%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>Hybird 搭建客户端实时降级架构</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Router真是一个非常好的一种设计模式, 能够做到超低的耦合, 作为系列的最后一节, 我们来统筹三端, 实现热修复架构, 再来说下这个架构的定义, 就是当Native页面业务逻辑出现Bug时, 又不能马上打包上线通过审核的情况下, 通过后台配置将页面降级为H5的页面, 等待修复完成上线后再回到Native的设计思想.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3866097366648136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;参考链接&quot;&gt;参考链接:&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5a03995a6ce1&quot;&gt;Hybird 搭建零耦合架构从MVC开始&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/846b9f181cb7&quot;&gt;Hybird 搭建后端Koa.js并过度到MVVM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/8d4a84e3ddaa&quot;&gt;Hybird 搭建前端Vue.js并升级至MVP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/36314d0c0032&quot;&gt;Hybird 搭建路由Router实现组件化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下内容在上述文章基础上进行, 请事先查阅.&lt;/p&gt;

&lt;p&gt;不过写到这里, 不禁感觉自己写的这个架构不是传统意义上的热更新, 而是变相的替代, 就像AT&amp;amp;T的蜂窝数据从LTE降到3G一样, 就是加载的速度上的差异, 但想必也比有Bug来的好吧.&lt;/p&gt;

&lt;p&gt;我们还是先来完成前端的页面吧, 作为M站, 导航栏在浏览器的访问下需要显示而在移动端的降级时不需要, 所以我们先来完成这项工作, 首先我们需要通过get参数来判断跳转情况.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;src
├── javascripts
│   ├── http.js
│   └── regex.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;regex.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export function URLQuery(key) {

  let reg = new RegExp(&quot;(^|&amp;amp;)&quot; + key + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;);
  let r = window.location.search.substr(1).match(reg);
  if (r != null) {
    return unescape(r[2]);
  }
  return null;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接着我们创建导航组件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;src
├── components
│   ├── J1.vue
│   └── navigation.vue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;navigation.vue&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template lang=&quot;html&quot;&amp;gt;
  &amp;lt;div v-show=&quot;show&quot;&amp;gt;
    &amp;lt;div class=&quot;nav&quot;&amp;gt;
        &amp;lt;span class=&quot;title&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;nav-offset&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import {
  URLQuery
} from '../javascripts/regex'

export default {
  data () {
    return {
      show: true
    }
  },
  props: {
    documentTitle: String
  },
  mounted:function () {
    if (URLQuery('client') === 'app') {
      this.show = false;
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;

.nav {
    width: 100%;
    height: 44px;
    position: relative;
    background: rgba(248,248,248,1.0);
    border-bottom: 1px solid lightgray;
    position: fixed;
    top: 0px;
    left: 0px;
    z-index: 1;
}

.nav-offset {
    height: 44px;
}

.title {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

&amp;lt;/style&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在J1.vue中挂载子组件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;lt;template lang=&quot;html&quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;navigation :documentTitle=&quot;title&quot;&amp;gt;&amp;lt;/navigation&amp;gt; //update
    &amp;lt;div class=&quot;cell&quot; v-for=&quot;model in models&quot;&amp;gt;
        ![](model.imageUrl)
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import navigation from './navigation' //update
import { GET,URL } from '../javascripts/http'
import { URLQuery } from '../javascripts/regex' //update

export default {
  data () {
    return {
      title: '',
      models: []
    }
  },
  components: { //update
    navigation
  },
  methods: {
    request: function() {
      GET(URL.getJ1List).then((data) =&amp;gt; {
          this.models = data.models;
      }).catch((error) =&amp;gt; {

      })
    }
  },
  mounted:function () {
    this.title = document.title = &quot;J1&quot;;
    this.request();
    // alert(window.location.href);
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;

.cell {
    height: 100px;
    position: relative;
    border-bottom: 1px solid lightgray;
}

.cell img {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    padding-left: 10px;
}

.cell span:first-of-type {
    position: absolute;
    top: 35%;
    transform: translateY(-35%);
    padding-left: 84px;
    font-size: 15px;
}

.cell span:last-of-type {
    position: absolute;
    top: 65%;
    transform: translateY(-65%);
    padding-left: 84px;
    font-size: 12px;
}

&amp;lt;/style&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在移动端对webView页面进行传参:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension Router {
    
    func addParam(key: String, value: Any) {
        params?[key] = value
    }
    
    func clearParams() {
        params?.removeAll()
    }
    
    func push(_ path: String) {
        
        guardRouters {
            guard let state = self.routers?[path] as? String else { return }
            
            if state == &quot;app&quot; {
                guard let nativeController = NSClassFromString(&quot;RouterPatterm.\(self.map[path]!)&quot;) as? UIViewController.Type else { return }
                currentController?.navigationController?.pushViewController(nativeController.init(), animated: true)
            }
            
            if state == &quot;web&quot; { //update
                
                let host = &quot;http://localhost:3000/&quot;
                var query = &quot;&quot;
                let ref = &quot;client=app&quot;
                
                guard let params = self.params else { return }
                for (key, value) in params {
                    query += &quot;\(key)=\(value)&amp;amp;&quot;
                }
                
                self.clearParams()
                
                let webViewController = WebViewController(&quot;\(host)\(path)?\(query)\(ref)&quot;)
                currentController?.navigationController?.pushViewController(webViewController, animated: true)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过client是不是app来判断导航栏的显示和隐藏, 接下来我们通过WKWebView来进行对JS的通讯:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class WebViewController: ViewController {
    
    fileprivate lazy var configuretion: WKWebViewConfiguration = { [weak self] in
        let configuretion = WKWebViewConfiguration()
        configuretion.userContentController.add(self!, name: &quot;push&quot;) //update
        configuretion.userContentController.add(self!, name: &quot;params&quot;) //update
        return configuretion
    }()
    
	...    
}

extension WebViewController: WKScriptMessageHandler {
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { //update
        
        let methods = &quot;\(message.name):&quot;
        let selector = NSSelectorFromString(methods)
        if self.responds(to: selector) {
            self.perform(selector, with: message.body)
        }
    }
}

extension WebViewController {
    
    @objc fileprivate func push(_ path: String) { //update
        Router.shareRouter.push(path)
    }
    
    @objc fileprivate func params(_ params: [String : Any]) { //update
        Router.shareRouter.params = params
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在JS中添加跳转和添加参数的方法并通过runtime的方法匹配SEL原生方法, 接下来, 我们在前端中也加入交互的代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── javascripts
│   ├── http.js
│   ├── native.js
│   └── regex.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;native.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
export function NativePush(path) {
  window.webkit.messageHandlers.push.postMessage(path);
}

export function NativeParams(params) {
  window.webkit.messageHandlers.params.postMessage(params);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;并在J1.vue中添加上交互逻辑&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template lang=&quot;html&quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;navigation :documentTitle=&quot;title&quot;&amp;gt;&amp;lt;/navigation&amp;gt;
    &amp;lt;div class=&quot;cell&quot; v-for=&quot;model in models&quot; @click=&quot;push('J1')&quot;&amp;gt; //update
        ![](model.imageUrl)
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import navigation from './navigation'
import { GET,URL } from '../javascripts/http'
import { URLQuery } from '../javascripts/regex'
import { NativePush, NativeParams } from '../javascripts/native' //update

export default {
  data () {
    return {
      title: '',
      models: []
    }
  },
  components: {
    navigation
  },
  methods: {
    request: function() {
      GET(URL.getJ1List).then((data) =&amp;gt; {
          this.models = data.models;
      }).catch((error) =&amp;gt; {

      })
    },
    push : function(path) { //update
      if (URLQuery('client') === 'app') {
          let params = {
            text : &quot;web端 传入数据&quot;,
            code : 1002
          }
          NativeParams(params);
          NativePush(path);
      } else {
          this.$router.push({
                path: '/' + path
          });
      }
    }
  },
  mounted:function () {
    this.title = document.title = &quot;J1&quot;;
    this.request();
    // alert(window.location.href);
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们的架构设计就算基本完成了.&lt;/p&gt;

&lt;p&gt;彩蛋:
为我们的后端连上数据库吧, 通过接口改变数据库的值不用重启服务就能够操控页面.
数据库我们在这里使用&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;mongodb&lt;/a&gt;, 当然你也可以使用大众情人mysql, 随便…&lt;/p&gt;

&lt;p&gt;安装完成后我们执行&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$ mongod –config /usr/local/etc/mongod.conf 开启服务.&lt;/li&gt;
  &lt;li&gt;$ use J1 //创建数据库&lt;/li&gt;
  &lt;li&gt;$ switched to db J1 //切换到数据库&lt;/li&gt;
  &lt;li&gt;$ db.createCollection(‘routers’) //创建routers集合&lt;/li&gt;
  &lt;li&gt;$ db.routers.insert({‘J1’ : ‘app’}) //插入数据到集合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样我们数据库的准备工作就完成了, 对于Node我们在package.json中导入mongoose, 然后在后端的目录结构上添加db路径:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db
├── J1
│   └── routers.js
├── base.js
└── config.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;config.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mongoose = require('mongoose');

var db = mongoose.connect('mongodb://localhost/J1');

db.connection.on(&quot;error&quot;, function(error) {
    console.log(&quot;database connect fail：&quot; + error);
});

db.connection.on(&quot;open&quot;, function() {
    console.log(&quot;database connect success&quot;);
})

db.connection.on('disconnected', function() {
    console.log('database disconnected');
})

exports.mongoose = mongoose;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;base.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mongodb = require('./config');
let mongoose = mongodb.mongoose;
let Schema = mongoose.Schema;
let ObjectId = Schema.Types.ObjectId;

exports.mongodb = mongodb;
exports.mongoose = mongoose;
exports.Schema = Schema;
exports.ObjectId = ObjectId;
exports.Mixed = Schema.Types.Mixed;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;routers.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let base = require('../base');
let ObjectId = base.ObjectId;
let Scheme = new base.Schema({
    J1: String
});

module.exports = base.mongoose.model('routers', Scheme);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在接口中调用数据库:&lt;/p&gt;

&lt;p&gt;J1.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.getRouters = async(ctx, next) =&amp;gt; {

    var routers = await Routers.find({});
    ctx.body = {
        routers: routers[0]
    }
}

exports.updateRouters = async(ctx, next) =&amp;gt; {

    const controller = ctx.params.controller;
    const client = ctx.params.client;

    if (controller === 'J1') {
        Routers.update({
            J1: client
        }, (err, doc) =&amp;gt; {
            console.log(doc);
        })
    } else {
        console.log('controller is not exist');
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;添加路由:&lt;/p&gt;

&lt;p&gt;J1_router.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
var router = require('koa-router')();
var J1 = require('../../app/controllers/J1');

router.get('/getRouters', J1.getRouters);
router.get('/updateRouters/:controller/:client', J1.updateRouters); //update
router.get('/getJ1List', J1.getJ1List);

module.exports = router;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们在服务全部开启的情况下调用updateRouters接口,&lt;/p&gt;

&lt;p&gt;浏览器输入:
http://localhost:3001/api/J1/updateRouters/J1/web
http://localhost:3001/api/J1/updateRouters/J1/app&lt;/p&gt;

&lt;p&gt;我们就能够直接更改数据库动态的降级或升级页面了.&lt;/p&gt;

&lt;p&gt;最后来总结一下, 我们通过了Swift3 + Vue2 + Koa2, 实现了可降级的移动端架构:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;cd /RouterPattern/server/RouterPattern $ npm start 开启接口服务器&lt;/li&gt;
  &lt;li&gt;cd /RouterPattern/server/RouterPattern/public/javascripts $ node image.js 开启图片服务器&lt;/li&gt;
  &lt;li&gt;cd /RouterPattern/web/RouterPattern $ npm run dev 打开前端页面&lt;/li&gt;
  &lt;li&gt;cd /RouterPattern/app/RouterPattern $ open RouterPatterm.xcworkspace 打开Xcode&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是我想与大家分享的设计思想, 希望大家提出宝贵意见.&lt;/p&gt;

&lt;p&gt;演示效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-32c9c5e7c147b54a.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;RouterPattern.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Apr 2017 16:37:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%99%8D%E7%BA%A7%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%99%8D%E7%BA%A7%E6%9E%B6%E6%9E%84/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>Hybird 搭建路由Router实现组件化</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;MVP是个非常好的设计模式, 能够进行代码解耦, 业务分层, 组件化必备良品, 但是还能不能再提升一步呢? 现在项目中的耦合是很少了, 但是控制器之前的切换还是有耦合存在, 有什么办法能够实现控制器零耦合呢?? 那就要祭出本系列的核心Router模式了.代码见: &lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3866097366648136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;参考链接&quot;&gt;参考链接:&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5a03995a6ce1&quot;&gt;Hybird 搭建零耦合架构从MVC开始&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/846b9f181cb7&quot;&gt;Hybird 搭建后端Koa.js并过度到MVVM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/8d4a84e3ddaa&quot;&gt;Hybird 搭建前端Vue.js并升级至MVP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下内容在上述文章基础上进行, 请事先查阅.&lt;/p&gt;

&lt;p&gt;零耦合一直都是神话般的存在, 但是身边的负能量总是不绝于耳, 不要为了用设计模式而设计模式, 诶.. 我们还是回到Router上来吧, 究竟如何才能构建Router架构呢? 不急, 我们先把前端的项目给搭建完毕吧.&lt;/p&gt;

&lt;p&gt;首先我们将端口号改为3000, 对应端口 前端: 3000, 接口服务器: 3001, 图片服务器: 3002&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── config
  ├── dev.env.js
  ├── index.js
  └── prod.env.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;index.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dev: {
    env: require('./dev.env'),
    port: 3000, //update
    autoOpenBrowser: true,
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {},
    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;
    // with this option, according to the CSS-Loader README
    // (https://github.com/webpack/css-loader#sourcemaps)
    // In our experience, they generally work as expected,
    // just be aware of this issue when enabling this option.
    cssSourceMap: false
  }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们先在package.json中添加网络请求axios, Vue2开始的官方推荐,&lt;/p&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;dependencies&quot;: {
    &quot;axios&quot;: &quot;^0.15.3&quot;,
    &quot;element-ui&quot;: &quot;^1.1.2&quot;,
    &quot;stylus&quot;: &quot;^0.54.5&quot;,
    &quot;stylus-loader&quot;: &quot;^2.4.0&quot;,
    &quot;vue&quot;: &quot;^2.1.0&quot;,
    &quot;vue-router&quot;: &quot;^2.1.1&quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并在src下创建javascripts 和 stylesheets 两个目录:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── App.vue
├── assets
│   └── logo.png
├── components
├── javascripts
├── main.js
├── router
│   └── index.js
└── stylesheets
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并在javascripts中添加http.js来执行网路请求脚本:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── javascripts
    ├── http.js

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;http.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import axios from 'axios'

export function GET(url) {

  return new Promise((resolve, reject) =&amp;gt; {
    axios.get(url).then((response) =&amp;gt; {
      resolve(response.data.data);
    }).catch((error) =&amp;gt; {
      reject(error);
    })
  });
}

export const URL = {
  getJ1List: 'http://localhost:3001/api/J1/getJ1List'
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码也很简单, 和之前Swift的Alamofire一样, 在外面封装一层, 使用ES6语法的Promise, 并定义接口URL.&lt;/p&gt;

&lt;p&gt;接着我们将Hello.vue修改为J1.vue&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── src
  ├── components
    └── J1.vue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;J1.vue&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;lt;template lang=&quot;html&quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div class=&quot;cell&quot; v-for=&quot;model in models&quot;&amp;gt;
        ![](model.imageUrl)
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import { GET,URL } from '../javascripts/http'

export default {
  data () {
    return {
      title: '',
      models: []
    }
  },
  methods: {
    request: function() {
      GET(URL.getJ1List).then((data) =&amp;gt; {
          this.models = data.models;
      }).catch((error) =&amp;gt; {

      })
    }
  },
  mounted:function () {
    this.title = document.title = &quot;J1&quot;;
    this.request();
    // alert(window.location.href);
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;

.cell {
    height: 100px;
    position: relative;
    border-bottom: 1px solid lightgray;
}

.cell img {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    padding-left: 10px;
}

.cell span:first-of-type {
    position: absolute;
    top: 35%;
    transform: translateY(-35%);
    padding-left: 84px;
    font-size: 15px;
}

.cell span:last-of-type {
    position: absolute;
    top: 65%;
    transform: translateY(-65%);
    padding-left: 84px;
    font-size: 12px;
}

&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接下来我们修改路由:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── src
  ├── router
    └── index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Vue from 'vue'
import Router from 'vue-router'
import J1 from '../components/J1'

Vue.use(Router)

export default new Router({
  routes: [{
      path: '/',
      component: J1
    },
    {
      path: '/J1',
      component: J1
    },
    {
      path: '*',
      redirect: '/'
    }
  ]
})

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行一下, 怎么什么都没有, 这个就要说到ajax的跨域问题了, 我们这里不展开, 对跨域有疑问的同学请自行Google.&lt;/p&gt;

&lt;p&gt;要解决跨域, 我们通过在后端加载跨域权限的方式:&lt;/p&gt;

&lt;p&gt;在server/app.js 中添加:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const cors = require('koa-cors');

app.use(cors());

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当然你需要 npm install一下了, 这样我们就能看见web端的显示了.&lt;/p&gt;

&lt;p&gt;前端不封叙述的有点多了, 但这对于热修复还是必须的, 我们回到移动端的项目上来, 在加载webView的时候将端口号改为3000, 这样我们在app端就能够加载刚才创建相同版本的web页面了.&lt;/p&gt;

&lt;p&gt;连载到现在, 我们发现了Koa中的接口是基于Router的, Vue中的页面跳转也是基于Router的, 那我们移动端能不能也有自己的Router跳转机制呢? 其实一些紧跟潮流的开发者都知道现在流行组件化, 而移动端组件化的代表就是Router, 也有一些第三方框架之类的, 孰优孰劣我没用过, 也不清楚, 在这里我只是基于对前端路由的理解来搭建一个移动端的路由, 首先我们添加一个Router.swift.&lt;/p&gt;

&lt;p&gt;Router.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Router {
    static let shareRouter = Router()
    var params: [String : Any]?
    fileprivate let map = [&quot;J1&quot; : &quot;Controller&quot;]
}


extension Router {
    
    func addParam(key: String, value: Any) {
        params?[key] = value
    }
    
    func clearParams() {
        params?.removeAll()
    }
    
    func push(_ path: String) {
        guard let nativeController = NSClassFromString(&quot;RouterPatterm.\(self.map[path]!)&quot;) as? UIViewController.Type else { return }
        currentController?.navigationController?.pushViewController(nativeController.init(), animated: true)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先Router必须是一个单例, Swift的单例比起Objective-C真是简单太多了, 来看我们的Router类, map是对应匹配跳转控制器,并可以添加参数, 删除参数, 和跳转的方法, 当然也可以加上pop等其他功能, 我这里就不演示, 有兴趣的同学自行研究.&lt;/p&gt;

&lt;p&gt;定义完成之后, 我们就可以进行使用了, 我们修改业务逻辑的Presenter.swift&lt;/p&gt;

&lt;p&gt;Presenter.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
extension Presenter: ViewOperation {
    
    func pushTo() {
        Router.shareRouter.params = [
            &quot;text&quot; : &quot;app端 传入数据&quot;,
            &quot;code&quot; : 1001
        ]
        Router.shareRouter.push(&quot;J1&quot;) //update
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在操作这里直接更改为使用Router跳转, 这样更具map定义的匹配, 我们就能够进行零耦合的页面跳转了. 如果需要传参也可以通过字典的形式存储在路由中, 当使用完成后对参数做清空操作就可以了.&lt;/p&gt;

&lt;p&gt;现在我们对移动端的路由跳转已经到位了, 接下啦该说说重点的热更新的思想了, 我们通过一个从服务器读取的字段来匹配该页面是跳转到移动端还是前端, 简单来说就是当移动端代码逻辑发生错误时怎么将移动端的页面降级为前端的页面. 这里我们在后端定义下获取跳转的接口.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;controllers
	└── J1.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;J1.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.getRouters = async(ctx, next) =&amp;gt; {

    ctx.body = {
        routers: {
            J1: 'web'
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;并挂载到路由上:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── api
│   ├── J1_router.js
│   └── index.js
├── index.js
└── users.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;J1_router&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
var router = require('koa-router')();
var J1 = require('../../app/controllers/J1');

router.get('/getRouters', J1.getRouters); //update
router.get('/getJ1List', J1.getJ1List);

module.exports = router;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过接口访问, 我们就能得到返回数据:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;routers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;J1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;web&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;回到移动端, 我们就可以根据这个接口来判断路由的跳转了.&lt;/p&gt;

&lt;p&gt;Router.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Router {
    static let shareRouter = Router()
    var params: [String : Any]?
    var routers: [String : Any]? //update
    fileprivate let map = [&quot;J1&quot; : &quot;Controller&quot;]
    
    func guardRouters(finishedCallback : @escaping () -&amp;gt; ()) { //update
        
        Http.requestData(.get, URLString: &quot;http://localhost:3001/api/J1/getRouters&quot;) { (response) in
            guard let result = response as? [String : Any] else { return }
            guard let data:[String : Any] = result[&quot;data&quot;] as? [String : Any] else { return }
            guard let routers:[String : Any] = data[&quot;routers&quot;] as? [String : Any] else { return }
            self.routers = routers
            finishedCallback()
        }
    }
}

extension Router {
    
    func addParam(key: String, value: Any) {
        params?[key] = value
    }
    
    func clearParams() {
        params?.removeAll()
    }
    
    func push(_ path: String) {
        
        guardRouters { //update
            guard let state = self.routers?[path] as? String else { return }
            
            if state == &quot;app&quot; {
                guard let nativeController = NSClassFromString(&quot;RouterPatterm.\(self.map[path]!)&quot;) as? UIViewController.Type else { return }
                currentController?.navigationController?.pushViewController(nativeController.init(), animated: true)
            }
            
            if state == &quot;web&quot; {
                let host = &quot;http://localhost:3000/&quot;
                let webViewController = WebViewController(&quot;\(host)&quot;)
                currentController?.navigationController?.pushViewController(webViewController, animated: true)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;现在我们在每次路由跳转的时候都请求到对应的页面状态就可以后台操作跳转Native还是H5了.&lt;/p&gt;

&lt;p&gt;回顾之前的代码, 我们现在已经做到了Model, View, ViewModel, Presenter和Controller之间的零耦合, 想想是不是有点小激动, 下一节内容, 我们会将Swift, Vue, Koa三端进行统筹, 实现真正的热修复框架.&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Apr 2017 13:40:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1Router%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E8%B7%AF%E7%94%B1Router%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>Hybird 搭建前端Vue.js并升级至MVP</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上回我们说到MVVM, 说真的我真没觉得MVVM为什么会鼓吹的那么神, 用大篇幅的叙述我着实提不起劲. 回顾一下内容, 我们通过Node.js搭建了图片服务器, 并通过Kingfisher加载出来, 说真的前两篇主要还是叙述移动端入门后端吧.. 噗.. 笑.. 这一节我们来说说MVP模式, 也是我比较喜欢以及推荐大家使用的一种设计思想. 代码见:&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3866097366648136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;参考链接&quot;&gt;参考链接:&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5a03995a6ce1&quot;&gt;Hybird 搭建零耦合架构从MVC开始&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/846b9f181cb7&quot;&gt;Hybird 搭建后端Koa.js并过度到MVVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下内容在上述文章基础上进行, 请事先查阅.&lt;/p&gt;

&lt;p&gt;看了网上好多类型的架构设计, 用那些玄乎的理论, 诸如高内聚低耦合, DRY等专有名词之类的泛泛而谈, 一条条提纲挈领的诉说着编写代码的该有的规范, 我不否认这些思想很重要, 但不能运用到实际上也只能是夸夸其谈罢了, 也许是我的道行略低不能企及那样的高度, 但光有思维方式不给实操方式, 与宗教又有何异? 总结就是, 对于架构设计, 不上代码就是扯!&lt;/p&gt;

&lt;p&gt;MVP&lt;/p&gt;

&lt;p&gt;MVP就是 Most Valuable Player, 最有价值球员.. 笑” 话说我大威少场均三双赛季封神啊, 言归正传, MVP在架构设计来说是指 Model, View, Presenter,  其中的Presenter指的是展示层, 操作页面逻辑的一层. MVP也是我最为推荐的一种设计模式, 做Android的同学应该有听说过适配器模式, 也就是Adapter, MVP中的Presenter就好像是双向的Adapter, 对代码进行完全的解耦实现组件化.&lt;/p&gt;

&lt;p&gt;我们来看看如何切换到MVP模式:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── Controller.swift
├── Model.swift
├── Presenter.swift
├── View.swift
└── ViewModel.swift
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们在目录结构中添加Presenter.swift&lt;/p&gt;

&lt;p&gt;Presenter.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
protocol ModelInterface {
    var text : String {get set}
    var detailText : String {get set}
    var imageUrl : String {get set}
}

protocol ViewInterface {
    var viewModel: ViewModelInterface? {get set}
}

protocol ViewModelInterface {
    var models: [ModelInterface] {get set}
    mutating func dynamicBinding(finishedCallback : @escaping () -&amp;gt; ())
}

class Presenter {
    var view: ViewInterface?
    var viewModel: ViewModelInterface?
}

extension Presenter {
    
    func adapter&amp;lt;VM: ViewModelInterface,V: ViewInterface&amp;gt;(viewModel: VM,  view: V) {
        
        self.view = view;
        self.viewModel = viewModel
        
        func dynamicBinding() {
            self.viewModel?.dynamicBinding {
                self.view?.viewModel = viewModel
            }
        }; dynamicBinding()
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MVP模式还是有必要详细的说明一下的, 我们对于Model, View, ViewModel, 也就是之前的MVVM对应的定义协议, 协议在Java中也叫接口, 就是制定一套大家都该遵守的规范. 将MVVM全部抽象化就是Presenter层的主要职责.&lt;/p&gt;

&lt;p&gt;我们对应修改代码, 使其遵守Presenter定义的协议.&lt;/p&gt;

&lt;p&gt;Model.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Model: NSObject, ModelInterface { //update
    
    var text : String = &quot;&quot;
    var detailText : String = &quot;&quot;
    var imageUrl : String = &quot;&quot;
    
    init(dict : [String : Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;View.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class View: UIView, ViewInterface { //update
    
    var value: ViewModelInterface? //update
    var viewModel: ViewModelInterface? { //update
        
        get { return value }
        set {
            value = newValue
            tableView.reloadData()
        }
    }
    
    fileprivate lazy var tableView: UITableView = { [weak self] in
        var tableView = UITableView(frame: self!.bounds, style: .plain)
        tableView.dataSource = self
        tableView.delegate = self
        return tableView
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        addSubview(tableView)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

extension View: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return viewModel?.models.count ?? 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        
        let identifier = &quot;identifier&quot;
        let model: ModelInterface? = viewModel?.models[indexPath.row] //update
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier) ?? UITableViewCell(style: .subtitle, reuseIdentifier: identifier)
        cell.textLabel?.text = model?.text
        cell.detailTextLabel?.text = model?.detailText
        cell.imageView?.loadUrl(imageUrl: model?.imageUrl)
        return cell
    }
}

extension View: UITableViewDelegate {
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat {
        return 100
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ViewModel.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewModel: ViewModelInterface { //update
    lazy var models: [ModelInterface] = [ModelInterface]() //update
}

extension ViewModel {
    
    func dynamicBinding(finishedCallback : @escaping () -&amp;gt; ()) {
        
        Http.requestData(.get, URLString: &quot;http://localhost:3001/api/J1/getJ1List&quot;) { (response) in
            guard let result = response as? [String : Any] else { return }
            guard let data:[String : Any] = result[&quot;data&quot;] as? [String : Any] else { return }
            guard let models:[[String : Any]] = data[&quot;models&quot;] as? [[String : Any]] else { return }
            
            self.models.removeAll()
            for dict in models {
                self.models.append(Model(dict: dict))
            }
            
            finishedCallback()
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Controller.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class Controller: UIViewController {

    fileprivate lazy var viewModel: ViewModel = ViewModel()
    fileprivate lazy var presenter: Presenter = Presenter() //update
    fileprivate lazy var baseView: View = { [weak self] in
        return View(frame: self!.view.bounds)
    }()
    
    override func loadView() {
        super.loadView()
        title = &quot;J1&quot;
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupView()
        adapterView()
    }
}

extension Controller {
    
    fileprivate func setupView() {
        view.addSubview(baseView)
    }
    

    fileprivate func adapterView() {
        presenter.adapter(viewModel: viewModel, view: baseView) //update
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后我们在Controller中引入Presenter, 并对View和ViewModel进行适配.&lt;/p&gt;

&lt;p&gt;运行一下, 和之前一样没有什么异常, 但代码之间已经完全的零耦合了, 只要遵守Presenter内所定义的协议, 替换掉任意一个部件, 也不会有什么问题. 这种代码设计就能够轻松的实现组件化了.&lt;/p&gt;

&lt;p&gt;但Presenter仅仅是负责这点工作吗? 其实我们可以将View中的逻辑也通过协议的形式接入进来, 具体如何实现, 不急, 我们先构建一个前端的项目吧!&lt;/p&gt;

&lt;p&gt;对于前端, 我使用的框架是尤雨溪大神的&lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue&lt;/a&gt;, 对于为什么使用Vue而不使用Google的Angluar, 或是Facebook的React, 哎.. 就是任性, 随便…&lt;/p&gt;

&lt;p&gt;和之前的Koa一样, 我们也找一个生成器吧, 好在Vue三件套中就有生成器cli, 好吧专业名词脚手架 - - , 我们就通过它来快速构建前端工程吧!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$ npm install webpack -g&lt;/li&gt;
  &lt;li&gt;$ npm install vue-cli -g&lt;/li&gt;
  &lt;li&gt;cd 目录 $ vue init webpack RouterPattern&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;? Project name routerpattern
? Project description A Vue.js project
? Author zhushuangquan &amp;lt;zhushuangquan@j1.com&amp;gt;
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? Yes
? Pick an ESLint preset Standard
? Setup unit tests with Karma + Mocha? Yes
? Setup e2e tests with Nightwatch? Yes

   vue-cli · Generated &quot;RouterPattern&quot;.

   To get started:
   
     cd RouterPattern
     npm install
     npm run dev
   
   Documentation can be found at https://vuejs-templates.github.io/webpack

// webpack的项目不能用大写字母, 所以我们都改为小写.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── README.md
├── build
│   ├── build.js
│   ├── check-versions.js
│   ├── dev-client.js
│   ├── dev-server.js
│   ├── utils.js
│   ├── vue-loader.conf.js
│   ├── webpack.base.conf.js
│   ├── webpack.dev.conf.js
│   └── webpack.prod.conf.js
├── config
│   ├── dev.env.js
│   ├── index.js
│   └── prod.env.js
├── index.html
├── package.json
├── src
│   ├── App.vue
│   ├── assets
│   │   └── logo.png
│   ├── components
│   │   └── Hello.vue
│   ├── main.js
│   └── router
│       └── index.js
└── static

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;终端执行 $ npm install  $ npm run dev 后在localhost:8080 上就能看到欢迎页面了.&lt;/p&gt;

&lt;p&gt;前端的部分我们就先到这里, 我们回到移动端来, 有了Web页面, 对应的我们就需要创建WebView了.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import WebKit

class WebViewController: UIViewController {
    
    fileprivate lazy var configuretion: WKWebViewConfiguration = { [weak self] in
        let configuretion = WKWebViewConfiguration()
        return configuretion
    }()
    
    fileprivate lazy var webView: WKWebView = { [weak self] in
        let webView = WKWebView(frame: self!.view.bounds)
        webView.navigationDelegate = self
        webView.uiDelegate = self
        return webView
    }()
    
    fileprivate lazy var progressView: UIProgressView = {
        let progressView = UIProgressView(frame: CGRect(x: 0, y: 65, width: self.view.bounds.size.width, height: 2))
        progressView.trackTintColor = .clear
        return progressView
    }()
    
    fileprivate var absoluteUrl = &quot;&quot;
    
    init (_ url: String) {
        super.init(nibName: nil, bundle: nil)
        absoluteUrl = url.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? &quot;&quot;
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(webView)
        view.addSubview(progressView)
        
        func loadRequest() {
            var request = URLRequest(url: URL(string: absoluteUrl)!)
            request.addValue(&quot;skey=skeyValue&quot;, forHTTPHeaderField: &quot;Cookie&quot;)
            webView.addObserver(self, forKeyPath: &quot;estimatedProgress&quot;, options: [.new, .old], context: nil)
            webView.load(request)
        }; loadRequest()
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        
        if keyPath == &quot;estimatedProgress&quot; {
            progressView.alpha = 1.0
            progressView.setProgress(Float(webView.estimatedProgress), animated: true)
            if webView.estimatedProgress &amp;gt;= 1.0 {
                UIView.animate(withDuration: 0.25, delay: 0.25, options: [.curveEaseOut], animations: {
                    self.progressView.alpha = 0.0
                    }, completion: { (finished) in
                        self.progressView.setProgress(0.0, animated: true)
                })
            }
        }
    }
    
    deinit {
        webView.removeObserver(self, forKeyPath: &quot;estimatedProgress&quot;)
    }
}

extension WebViewController: WKNavigationDelegate {
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        title = webView.title
    }
}

extension WebViewController: WKUIDelegate {
    
    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -&amp;gt; Void) {
        
        let alertViewController = UIAlertController(title: nil, message: message, preferredStyle: .alert)
        alertViewController.addAction(UIAlertAction(title: &quot;确定&quot;, style: .default, handler: { (action) in
            completionHandler()
        }))
        
        present(alertViewController, animated: false, completion: nil)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之前的UIWebView的简单交互已经有讲解, 这次就使用最新的WKWebView吧. 代码没什么说的, 只不过WK的内核相同, 与JS交互更加方便了, 这个我们下次再谈.&lt;/p&gt;

&lt;p&gt;我们点击cell让它push到刚才vue的展示页, 在View中拿到当前控制器不方便, 我们创建一个全局变量来保存当前控制器.&lt;/p&gt;

&lt;p&gt;ViewController.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var currentController: ViewController?

class ViewController: UIViewController {
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        currentController = self
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再让Controller和WebViewController继承与ViewController, 这样在哪里都能拿到当前控制器了.&lt;/p&gt;

&lt;p&gt;View.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        currentController?.navigationController?.pushViewController(WebViewController(&quot;http://localhost:8080/&quot;), animated: true)
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就能够跳转到刚才Vue生成的页面了, 但是这种跳转逻辑写在View中, 不是很好维护, 这时Presenter, 就能够实行它的第二个用途了 – 统筹业务逻辑.&lt;/p&gt;

&lt;p&gt;我们在View中定义操作协议: ViewOperation&lt;/p&gt;

&lt;p&gt;View.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
protocol ViewOperation { //update
    mutating func pushTo() -&amp;gt; Void
}

class View: UIView, ViewInterface {
    
    var operation: ViewOperation? //update
    var value: ViewModelInterface?
    var viewModel: ViewModelInterface? {
        
        get { return value }
        set {
            value = newValue
            tableView.reloadData()
        }
    }
    
    fileprivate lazy var tableView: UITableView = { [weak self] in
        var tableView = UITableView(frame: self!.bounds, style: .plain)
        tableView.dataSource = self
        tableView.delegate = self
        return tableView
        }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        addSubview(tableView)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

extension View: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return viewModel?.models.count ?? 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        
        let identifier = &quot;identifier&quot;
        let model: ModelInterface? = viewModel?.models[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier) ?? UITableViewCell(style: .subtitle, reuseIdentifier: identifier)
        cell.textLabel?.text = model?.text
        cell.detailTextLabel?.text = model?.detailText
        cell.imageView?.loadUrl(imageUrl: model?.imageUrl)
        return cell
    }
}

extension View: UITableViewDelegate {
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat {
        return 100
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        operation?.pushTo() //update
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Presenter中进行实现&lt;/p&gt;

&lt;p&gt;Presenter.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
extension Presenter: ViewOperation {
    
    func pushTo() {
        currentController?.navigationController?.pushViewController(WebViewController(&quot;http://localhost:8080/&quot;), animated: true)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们把业务逻辑都抽象出来了, Presenter中既能拿到数据又能拿到视图还能进行业务操作, 简直太棒了, 这就是我向你推荐的MVP模式!&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 15:06:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFVue.js%E5%B9%B6%E5%8D%87%E7%BA%A7%E8%87%B3MVP/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFVue.js%E5%B9%B6%E5%8D%87%E7%BA%A7%E8%87%B3MVP/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
      <item>
        <title>Hybird 搭建后端Koa.js并过度到MVVM</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;回顾上期的内容, 我们通过Koa搭建服务器实现了移动端与后端的交互, 使得app不再只是个壳子,  通过CocoaPods集成了Alamofire成功调用后端的API, 实现了最精简也是最经典的MVC架构, 今天我们来说说之前大热的MVVM架构.代码详见:&lt;a href=&quot;coderZsq.target.swift&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3866097366648136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;参考链接&quot;&gt;参考链接:&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5a03995a6ce1&quot;&gt;Hybird 搭建零耦合架构从MVC开始&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下内容在上述文章基础上进行, 请事先查阅.&lt;/p&gt;

&lt;p&gt;其实现在iOS开发还是在Objective-C的大环境下, 让我在项目中使用MVVM这种架构, 其实我是拒绝的, 因为个人觉得OC的代码设计是不适合使用MVVM框架的, 具体原因就是 “丑”, 一个字代表了所有的观点. 但作为技术研讨, MVVM的思想还是有向大家普及的必要的.&lt;/p&gt;

&lt;p&gt;MVVM&lt;/p&gt;

&lt;p&gt;MVVM是指 Model, View, ViewModel, 这里的ViewModel代替了原先Controller的部分工作, MVVM的概念最初是从前端开始的, 以后面会说到的Vue举例, 每一个Vue文件就是一个ViewModel, 实现了动态绑定的功能, 通俗的说就是当数据发生改变, 视图立即改变, 相反当用户操作视图也同时操作了数据. ViewModel从名字上来看就是View和Model的中间层.&lt;/p&gt;

&lt;p&gt;接下来我们来看一下移动端怎么实现MVVM架构:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── Controller.swift
├── Model.swift
├── View.swift
└── ViewModel.swift

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们先在项目结构下添加ViewModel.swift, 将之前在Controller中的网络请求代码移植到VM中:&lt;/p&gt;

&lt;p&gt;ViewModel.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewModel {
    lazy var models: [Model] = [Model]()
}

extension ViewModel {
    
    func dynamicBinding(finishedCallback : @escaping () -&amp;gt; ()) {
        
        Http.requestData(.get, URLString: &quot;http://localhost:3001/api/J1/getJ1List&quot;) { (response) in
            guard let result = response as? [String : Any] else { return }
            guard let data:[String : Any] = result[&quot;data&quot;] as? [String : Any] else { return }
            guard let models:[[String : Any]] = data[&quot;models&quot;] as? [[String : Any]] else { return }
            
            self.models.removeAll()
            for dict in models {
                self.models.append(Model(dict: dict))
            }
            
            finishedCallback()
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;小贴士:
Swift中的Class可以不用继承直接定义, 降低开销.&lt;/p&gt;

&lt;p&gt;我们对应修改其他代码如下:&lt;/p&gt;

&lt;p&gt;View.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class View: UIView {
    
    var viewModel: ViewModel? { //update
        
        didSet {
            tableView.reloadData()
        }
    }
    
    fileprivate lazy var tableView: UITableView = { [weak self] in
        var tableView = UITableView(frame: self!.bounds, style: .plain)
        tableView.dataSource = self
        return tableView
        }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        addSubview(tableView)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

extension View: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return viewModel?.models.count ?? 0 //update
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        
        let identifier = &quot;identifier&quot;
        let model: Model? = viewModel?.models[indexPath.row] //update
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier) ?? UITableViewCell(style: .subtitle, reuseIdentifier: identifier)
        cell.textLabel?.text = model?.text
        cell.detailTextLabel?.text = model?.detailText
        return cell
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Controller.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class Controller: UIViewController {

    fileprivate lazy var viewModel: ViewModel = ViewModel() //update
    fileprivate lazy var baseView: View = { [weak self] in
        return View(frame: self!.view.bounds)
    }()
    
    override func loadView() {
        super.loadView()
        title = &quot;J1&quot;
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupView()
        adapterView()
    }
}

extension Controller {
    
    fileprivate func setupView() {
        view.addSubview(baseView)
    }
    

    fileprivate func adapterView() { //update
        viewModel.dynamicBinding {
            self.baseView.viewModel = self.viewModel
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过将网络请求封装到ViewModel中实现了代码分层, 设计也更为简洁. 但是我们现在的用户界面好Low啊, 是不是应该做点什么? 对了, 我们给界面里添加点图片吧!&lt;/p&gt;

&lt;p&gt;当然图片我们也是通过后端获取, 我们在后端目录中添加image.js文件来实现图片服务器.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
└── public
  └── images
	└── image.js

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;image.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
const http = require('http');
const fs = require('fs');

http.createServer((req, res) =&amp;gt; {
    console.log(req.url);

    let path = '..' + decodeURI(req.url);
    fs.readFile(path, 'binary', (err, file) =&amp;gt; {
        if (err) {
            // console.log(err);
            return;
        } else {
            res.writeHead(200, {
                'Content-Type': 'image/png'
            });
            res.write(file, 'binary');
            res.end();
            return;
        }
    })
}).listen(3002);
console.log('port = 3002');

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里使用的是原生的Node.js搭建的图片服务器, 监听3002端口.&lt;/p&gt;

&lt;p&gt;这里我们来说说服务器是如何实现想客户端传送数据的, 我们现在分为API服务器: 3001和图片服务器: 3002. API服务器传输的类型是Content-Type : application/json这种格式的, 而图片服务器返回的是二进制的格式Content-Type’: ‘image/png. 原理就是将文本或数据写在Body上.&lt;/p&gt;

&lt;p&gt;我们cd 到目录中 通过node命令 $ node image.js 来执行js脚本文件. 看到port = 3002打印在终端上说明, 服务启动成功.&lt;/p&gt;

&lt;p&gt;有图片服务器, 没有图片怎么行? 我们在images中添加图片文件. 添加完后在浏览器中输入: http://localhost:3002/images/J1/关于健一@2x.png, 就能够访问到服务器的图片了.&lt;/p&gt;

&lt;p&gt;接下来我们将图片的URL地址通过API的形式返回给移动端调用.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
└── app
  └── controllers
	└── J1.js

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;J1.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.getJ1List = async(ctx, next) =&amp;gt; {

    ctx.body = {
        models: [{
            text: '我的账户',
            detailText: &quot;欢迎进入=&amp;gt;我的账户&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/我的账户@2x.png&quot;
        }, {
            text: '我的优惠券',
            detailText: &quot;欢迎进入=&amp;gt;我的优惠券&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/我的优惠券@2x.png&quot;
        }, {
            text: '收货地址',
            detailText: &quot;欢迎进入=&amp;gt;收货地址&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/收货地址@2x.png&quot;
        }, {
            text: '在线客服',
            detailText: &quot;欢迎进入=&amp;gt;在线客服&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/在线客服@2x.png&quot;
        }, {
            text: '用药提醒',
            detailText: &quot;欢迎进入=&amp;gt;用药提醒&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/用药提醒@2x.png&quot;
        }, {
            text: '药查查',
            detailText: &quot;欢迎进入=&amp;gt;药查查&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/药查查@2x.png&quot;
        }, {
            text: '疾病百科',
            detailText: &quot;欢迎进入=&amp;gt;疾病百科&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/疾病百科@2x.png&quot;
        }, {
            text: '药品百科',
            detailText: &quot;欢迎进入=&amp;gt;药品百科&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/药品百科@2x.png&quot;
        }, {
            text: '健一咨询',
            detailText: &quot;欢迎进入=&amp;gt;健一咨询&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/健一咨询@2x.png&quot;
        }, {
            text: '帮助中心',
            detailText: &quot;欢迎进入=&amp;gt;帮助中心&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/帮助中心@2x.png&quot;
        }, {
            text: '点赞/吐槽',
            detailText: &quot;欢迎进入=&amp;gt;点赞/吐槽&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/点赞:吐槽@2x.png&quot;
        }, {
            text: '关于健一',
            detailText: &quot;欢迎进入=&amp;gt;关于健一&quot;,
            imageUrl: &quot;http://localhost:3002/images/J1/关于健一@2x.png&quot;
        }]
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在浏览器访问接口 http://localhost:3001/api/J1/getJ1List&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;models&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;我的账户&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;我的账户&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/我的账户@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;我的优惠券&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;我的优惠券&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/我的优惠券@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;收货地址&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;收货地址&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/收货地址@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;在线客服&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;在线客服&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/在线客服@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;用药提醒&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;用药提醒&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/用药提醒@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;药查查&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;药查查&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/药查查@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;疾病百科&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;疾病百科&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/疾病百科@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;药品百科&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;药品百科&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/药品百科@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;健一咨询&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;健一咨询&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/健一咨询@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;帮助中心&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;帮助中心&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/帮助中心@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;点赞/吐槽&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;点赞/吐槽&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/点赞:吐槽@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;关于健一&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;detailText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;欢迎进入=&amp;gt;关于健一&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;imageUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3002/images/J1/关于健一@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数据返回没有问题了, 接下来我们来看看如何从移动端访问服务器图片, 这里使用喵神的Kingfisher来请求图片, 之前已经通过Pods导入到项目中了.&lt;/p&gt;

&lt;p&gt;使用第三方框架的时候我们都需要在外面再封装一层, 我们创建Image.swift&lt;/p&gt;

&lt;p&gt;Image.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Kingfisher

extension UIImageView {
    
    func loadUrl(imageUrl: String?, placeholder: String = &quot;placeholder&quot;) {
        self.kf.setImage(with: URL(string: imageUrl?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? &quot;&quot;), placeholder: UIImage(named: placeholder), options: nil, progressBlock: nil, completionHandler: nil)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来在Model和View中添加imageUrl字段并修改如下:&lt;/p&gt;

&lt;p&gt;Model.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Model: NSObject {

    var text : String = &quot;&quot;
    var detailText : String = &quot;&quot;
    var imageUrl : String = &quot;&quot; //update

    init(dict : [String : Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;View.swift&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class View: UIView {
    
    var viewModel: ViewModel? {
        
        didSet {
            tableView.reloadData()
        }
    }
    
    fileprivate lazy var tableView: UITableView = { [weak self] in
        var tableView = UITableView(frame: self!.bounds, style: .plain)
        tableView.dataSource = self
        tableView.delegate = self //update
        return tableView
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        addSubview(tableView)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

extension View: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return viewModel?.models.count ?? 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
        
        let identifier = &quot;identifier&quot;
        let model: Model? = viewModel?.models[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier) ?? UITableViewCell(style: .subtitle, reuseIdentifier: identifier)
        cell.textLabel?.text = model?.text
        cell.detailTextLabel?.text = model?.detailText
        cell.imageView?.loadUrl(imageUrl: model?.imageUrl) //update
        return cell
    }
}

extension View: UITableViewDelegate { //update
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat {
        return 100
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以上就是个人理解的MVVM, 也说出你对于MVVM的想法, 我们一起探讨!&lt;/p&gt;

&lt;p&gt;About:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;点击下方链接跳转!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/coderZsq/coderZsq.target.swift&quot;&gt;🌟 源码 请点这里🌟 »&amp;gt; 喜欢的朋友请点喜欢 »&amp;gt; 下载源码的同学请送下小星星 »&amp;gt; 有闲钱的壕们可以进行打赏 »&amp;gt; 小弟会尽快推出更好的文章和大家分享 »&amp;gt; 你的激励就是我的动力!! &lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 12:42:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%90%8E%E7%AB%AFKoa.js%E5%B9%B6%E8%BF%87%E5%BA%A6%E5%88%B0MVVM/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Hybird-%E6%90%AD%E5%BB%BA%E5%90%8E%E7%AB%AFKoa.js%E5%B9%B6%E8%BF%87%E5%BA%A6%E5%88%B0MVVM/</guid>
        
        <category>移动开发</category>
        
        
      </item>
    
  </channel>
</rss>
