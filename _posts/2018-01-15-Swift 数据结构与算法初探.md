---
layout: post
title: Swift æ•°æ®ç»“æ„ä¸ç®—æ³•åˆæ¢
date: 2018.01.15 16:48
tag: ç§»åŠ¨å¼€å‘
---

> å»å¹´å¯¹è®¾è®¡æ¨¡å¼æœ‰äº†ä¸€äº›æµ…æ˜¾çš„çŸ¥è¯†, ä»Šå¹´æ¥å­¦ä¹ ä¸‹æ•°æ®ç»“æ„ä¸ç®—æ³•, ä¸ºäº†å­¦ä¹ ä»¥åçš„å…ˆè¿›æŠ€æœ¯æ‰“å¥½åŸºç¡€. æœ¬æ–‡åŒ…æ‹¬é˜Ÿåˆ—, æ ˆ, çº¿æ€§è¡¨, æ ‘, å›¾, äº”ä¸ªéƒ¨åˆ†æ¥å­¦ä¹ ç¼–ç¨‹çš„åŸºç¡€, ä¹Ÿå¤ä¹ ä¸‹Swiftçš„è¯­æ³•. 

æ•°æ®ç»“æ„å’Œç®—æ³•å’Œè®¾è®¡æ¨¡å¼ç›¸åŒ, å±äºç¼–ç¨‹çš„è½¯å®åŠ›, å¹¶ä¸å±€é™äºè¯­è¨€, è€Œç€é‡äºæ€æƒ³, æœ¬æ–‡å°±æ˜¯é€šè¿‡å­¦ä¹ æ€»ç»“å°†C++å®ç°çš„ç®—æ³•è¿ç§»åˆ°Swiftçš„è¿‡ç¨‹å¹¶äº†è§£å…·ä½“çš„å®ç°.

#### é˜Ÿåˆ—

é¦–å…ˆ, æˆ‘ä»¬ç¬¬ä¸€ä¸ªå°±è¦å­¦ä¹ çš„å°±æ˜¯é˜Ÿåˆ—è¿™ä¸ªæ•°æ®ç»“æ„, é˜Ÿåˆ—, é¡¾åæ€ä¹‰å°±æ˜¯æ’é˜Ÿ, ä¹Ÿå°±æ˜¯å…ˆè¿›å…ˆå‡º, æˆ‘ä»¬è¿™é‡Œé€šè¿‡Swiftæ¥å®ç°ä¸€ä¸ªé˜Ÿåˆ—, æ¥æ›´å¥½çš„äº†è§£è¿™ä¸ªæ•°æ®ç»“æ„.

```swift
    private var capacity: Int //é˜Ÿåˆ—çš„å®¹é‡å¤§å°é™åˆ¶.
    private lazy var head: Int = 0 //é˜Ÿåˆ—å¤´
    private lazy var tail: Int = 0 //é˜Ÿåˆ—å°¾ 
    private lazy var length: Int = 0 //é˜Ÿåˆ—é•¿åº¦
    private lazy var queue: [Element] = [Element]() //é˜Ÿåˆ—æ•°ç»„
```

æˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€äº›æˆå‘˜å˜é‡æ¥æ§åˆ¶è¿™ä¸ªé˜Ÿåˆ—, æˆ‘ä»¬å®ç°çš„è¿™ä¸ªé˜Ÿåˆ—æ¯”è¾ƒç‰¹æ®Š, å¹¶ä¸æ˜¯ä¸€ä¸ªçº¿æ€§é˜Ÿåˆ—, è€Œæ˜¯ç¯å½¢é˜Ÿåˆ—, è¿™æ ·çš„é˜Ÿåˆ—æ›´åŠ é€‚åˆæˆ‘ä»¬çš„ç¨‹åº.

```swift
    init(_ queueCapacity: Int = 16) {
        capacity = queueCapacity
    }
    
    func clear() {
        head = 0
        tail = 0
        length = 0
    }
    
    func isEmpty() -> Bool {
        return length == 0 ? true : false
    }
    
    func isFull() -> Bool {
        return length == capacity ? true : false
    }
    
    func size() -> Int {
        return length
    }

```
å®ç°äº†åˆå§‹åŒ–å’Œä¸€äº›å¿…è¦çš„å‡½æ•°, è¿™é‡Œå¾ˆå®¹æ˜“ç†è§£å°±ä¸è¿‡å¤šèµ˜è¿°.

```swift
    @discardableResult func entry(_ element: Element) -> Bool {
        guard !isFull() else { return false }
        queue.append(element)
        queue[tail] = element
        tail += 1
        tail %= capacity
        length += 1
        return true
    }
    
    @discardableResult func depart() -> Element? {
        guard !isEmpty() else { return nil }
        let element = queue[head]
        head += 1
        head %= capacity
        length -= 1
        return element
    }
```

è¿™æ˜¯å¯¹äºé˜Ÿåˆ—è¿™ä¸ªæ•°æ®ç»“æ„æœ€ä¸ºé‡è¦çš„ä¸¤ä¸ªå‡½æ•°, è¿›å…¥é˜Ÿåˆ—å’Œç¦»å¼€é˜Ÿåˆ—, å…¶å®ä¹Ÿéå¸¸å®¹æ˜“ç†è§£, ç”±äºæ˜¯ç¯å½¢é˜Ÿåˆ—æ‰€ä»¥å…³é”®ç‚¹åœ¨äº`tail %= capacity`å’Œ`head %= capacity`ä¸Š, å¯¹äºå–ä½™æ•°çš„æ¦‚å¿µå…¶å®å’Œä¹‹å‰çš„[æŠ•æœºæµè½®æ’­å›¾](https://coderzsq.github.io/2016/06/iOS-%E6%8A%95%E6%9C%BA%E6%B5%81%E5%AE%9E%E7%8E%B0-%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD%E5%9B%BE/)é‚£ç¯‡ç±»ä¼¼ç†è§£å³å¯.

```swift
    func traverse() {
        print("ï¸µ")
        for i in head..<length + head {
            print(queue[i % capacity])
        }
        print("ï¸¶")
    }
```
é˜Ÿåˆ—éå†çš„å‡½æ•°, ä¹Ÿå’Œå–ä½™æ•°ä¸€æ ·, ç¯å½¢é˜Ÿåˆ—çš„å¥½å¤„å’ŒTCPæ»‘åŠ¨çª—å£ä¹Ÿç±»ä¼¼, å¯ä»¥ä½œä¸ºå‚è€ƒ.

```swift
    let queue_i = Queue<Int>()
    queue_i.entry(1)
    queue_i.entry(2)
    queue_i.entry(3)
    queue_i.traverse() // (1, 2, 3)
    
    print(queue_i.depart()!) //1
    queue_i.traverse() //(2, 3)
    
    print(queue_i.depart()!) //2
    queue_i.traverse() //(3)
    
    queue_i.entry(4)
    queue_i.entry(5)
    queue_i.traverse() //(3, 4, 5)
    
    print(queue_i.depart()!) //3
    queue_i.traverse() //(4, 5)
```

é˜Ÿåˆ—çš„å®ç°ååˆ†ç®€å•, æˆ‘ä»¬æ¥ç”¨ä¸€ä¸‹è¿™ä¸ªæ•°æ®ç»“æ„, å¯ä»¥çœ‹åˆ°çš„ç¡®éµå¾ªäº†å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™, è¿™ä¹Ÿå°±æ˜¯é˜Ÿåˆ—è¿™ä¸ªæ•°æ®ç»“æ„äº†.

#### æ ˆ

æ¥ä¸‹æ¥, æˆ‘ä»¬æ¥è¯´è¯´æ ˆ, æœ‰äº†é˜Ÿåˆ—çš„åŸºç¡€, æˆ‘ä»¬å­¦ä¹ æ ˆä¹Ÿå¹¶ä¸æ˜¯é‚£ä¹ˆçš„è´¹åŠ², é˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡º, è€Œé˜Ÿåˆ—æ˜¯å…ˆè¿›åå‡º, åŒºåˆ«ä¹Ÿå°±åœ¨äºæ­¤.

```swift
    private var capacity: Int //æ ˆå®¹é‡
    private lazy var peek: Int = 0 //æ ˆé¡¶
    private lazy var buffer: [Element] = [Element]() //æ ˆç¼“å†²åŒº
```

å’Œå­¦ä¹ é˜Ÿåˆ—ç›¸åŒ, æˆ‘ä»¬ä¹Ÿå°†æˆå‘˜å˜é‡åˆ—å‡ºæ¥, èƒ½å¤Ÿæ›´å¥½çš„äº†è§£è¿™ä¸ªæ•°æ®ç»“æ„.

```swift
    @discardableResult func push(_ element: Element) -> Bool {
        guard !isFull() else { return false }
        buffer.append(element)
        buffer[peek] = element
        peek += 1
        return true
    }
    
    @discardableResult func pop() -> Element? {
        guard !isEmpty() else { return nil }
        peek -= 1
        return buffer[peek]
    }
```
åˆ¤ç©º, åˆ¤æ»¡, æ¸…ç©º, æ„é€ ä¹‹ç±»çš„åŸºç¡€å‡½æ•°å°±å¸¦è¿‡äº†, å¯ä»¥å»[github](https://github.com/coderZsq/coderZsq.target.swift)ä¸Šçœ‹ä»£ç , æˆ‘ä»¬è¿™é‡Œèšç„¦æ ˆçš„å…³é”®å‡½æ•°, è¿›æ ˆå’Œå‡ºæ ˆ. å—¯,çœ‹ä»£ç å°±èƒ½å¤Ÿäº†è§£, ä¹Ÿä¸è¿‡å¤šè®²è§£äº†. 

```swift
    func traverse(reversed: Bool = false) {
        print("ï¸µ")
        if reversed {
            for i in (0..<peek).reversed() {
                print(buffer[i])
            }
        } else {
            for i in 0..<peek {
                print(buffer[i])
            }
        }
        print("ï¸¶")
    }
```
éå†å‡½æ•°, æ­£åºéå†å’Œå€’åºéå†, å—¯. ä¹Ÿå¾ˆå®¹æ˜“ç†è§£.

```swift
    let stack_i = Stack<Int>(3)
    stack_i.push(1)
    stack_i.push(2)
    stack_i.push(3)
    stack_i.push(4)
    stack_i.traverse() //(1, 2, 3)

    print(stack_i.pop()!) //3
    stack_i.traverse() //(1, 2)

    stack_i.push(5)
    stack_i.push(6)
    stack_i.traverse() //(1, 2, 5)

    print(stack_i.pop()!) //5
    stack_i.traverse() //(1, 2)
```
æˆ‘ä»¬ä¹Ÿæ¥å®é™…ä½¿ç”¨ä¸‹æ ˆè¿™ä¸ªæ•°æ®ç»“æ„, å¯ä»¥çœ‹åˆ°å’Œé˜Ÿåˆ—ä¸åŒ, æ ˆæ˜¯éµå¾ªå…ˆè¿›åå‡ºçš„åŸåˆ™å°±ç±»ä¼¼äºåšç”µæ¢¯, å…ˆè¿›å»çš„äººæœ€åå‡ºæ¥. è¿™é‡Œä¸ºä»€ä¹ˆè¿›æ ˆ4ä¸ªå…ƒç´ , æ‰“å°åªæœ‰3ä¸ª, æ˜¯å› ä¸ºæˆ‘ä»¬çš„å®¹é‡é™åˆ¶ä¸º3, åˆ°è¾¾å®¹é‡é™åˆ¶å°±æ— æ³•å…¥æ ˆ, å°±å’Œç”µæ¢¯è¶…è½½å‘å‡ºè­¦æŠ¥ç±»ä¼¼.

```swift
    func converse(_ origin: Int , format: Int) -> String {
        let stack = Stack<Int>(30)
        var ori = origin
        var mod = 0
        var char = ["0","1","2","3","4","5","6","7","8","9",
                    "A","B","C","D","E","F"]
        var conversed = ""
        while ori != 0 {
            mod = ori % format
            stack.push(mod)
            ori /= format
        }
        while !stack.isEmpty() {
            guard let index = stack.pop() else { continue }
            conversed += char[index]
        }
        stack.clear()
        return "(\(conversed))"
    }
    print(converse(1000, format: 2)) //(1111101000)
    print(converse(1000, format: 8)) //(1750)
    print(converse(1000, format: 10)) //(1000)
    print(converse(123456789, format: 16)) //(75BCD15)
```
æ ˆè¿™ä¸ªæ•°æ®ç»“æ„å¯ä»¥åšåˆ°éå¸¸å¤šçš„äº‹æƒ…, æ¯”å¦‚è¯´è½¬æ¢è¿›åˆ¶, ä¸Šé¢å°±æ˜¯è¿›åˆ¶è½¬æ¢ä¸­æ ˆçš„åº”ç”¨.

```swift
    func match(_ brackets: String) -> Bool {
        let stack = Stack<Character>(30)
        let needStack = Stack<Character>(30)
        var currentNeed = Character(" ")
        for i in 0..<brackets.count {
            let char = brackets[brackets.index(brackets.startIndex, offsetBy: i)]
            if  char != currentNeed {
                stack.push(char)
                switch char {
                case "[":
                    if currentNeed != Character(" ") {
                        needStack.push(currentNeed)
                    }
                    currentNeed = "]"
                    break
                case "(":
                    if currentNeed != Character(" ") {
                        needStack.push(currentNeed)
                    }
                    currentNeed = ")"
                    break
                default:
                    return false
                }
            } else {
                stack.pop()
                guard let need = needStack.pop() else { currentNeed = Character(" "); continue }
                currentNeed = need
            }
        }
        return stack.isEmpty()
    }
    print(match("[]()[]()[]") ? "match" : "not match") //match
```
ä¸ä»…å¯ä»¥è½¬æ¢è¿›åˆ¶, è¿˜å¯ä»¥åˆ¤æ–­æ‹¬å·çš„åŒ¹é…, è¿™é‡Œå°±éœ€è¦2ä¸ªæ ˆçš„åº”ç”¨, æœ€ååˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ¥æ¨æ–­æ˜¯å¦åŒ¹é….

#### çº¿æ€§è¡¨

æ•°æ®ç»“æ„ä»çº¿æ€§è¡¨è¿™é‡Œå¼€å§‹éš¾æ˜“ç¨‹åº¦ä¸Šäº†ä¸€ä¸ªå°é˜¶, å¯¹äºçº¿æ€§è¡¨æ¥è¯´, æ ˆå’Œé˜Ÿåˆ—æ„Ÿè§‰å°±æ˜¯é—¹ç€ç©çš„, å¥½äº†, æˆ‘ä»¬æ¥è¯´è¯´çº¿æ€§è¡¨.

çº¿æ€§è¡¨åˆ†ä¸º, æ•°ç»„å’Œé“¾è¡¨, æ•°ç»„å°±æ˜¯è¿ç»­çš„å†…å­˜åœ°å€, è€Œé“¾è¡¨åˆ™æ˜¯ä¸è¿ç»­çš„å†…å­˜åœ°å€é€šè¿‡æŒ‡é’ˆæŒ‡å‘æ¥ä¸²è”, æ¯”å¦‚æ¯ä¸ªä¿é™©ç®±é‡Œæœ‰ä¸€æŠŠèƒ½å¤Ÿæ‰“å¼€ä¸‹ä¸€ä¸ªä¿é™©ç®±çš„é’¥åŒ™, è€Œä¸‹ä¸€ä¸ªä¿é™©ç®±å†…åˆæœ‰ä¸€æŠŠæŒ‡å‘ä¸‹ä¸‹ä¸€ä¸ªä¿é™©ç®±çš„é’¥åŒ™, å¦‚æ­¤å¾€å¤, ä¾¿æ˜¯é“¾è¡¨.

##### æ•°ç»„

æˆ‘ä»¬æ¥å…ˆè¯´è¯´æ•°ç»„è¿™ä¸ªæ•°æ®ç»“æ„, å¯¹äºä¸€èˆ¬æˆ‘ä»¬å¼€å‘æ¥è¯´, æ•°ç»„æ˜¯æˆ‘ä»¬æœ€ä¸ºå¸¸ç”¨çš„å®¹å™¨ç±»äº†, ä½†æˆ‘ä»¬çœŸçš„äº†è§£æ•°ç»„çš„å®ç°è¿‡ç¨‹ä¹ˆ, æ¥çœ‹çœ‹å§.

```swift
    private var capacity: Int  = 0 //æ•°ç»„å®¹é‡
    private lazy var length: Int = 0 //æ•°ç»„é•¿åº¦
    private lazy var list: [Element] = [Element]() //æ•°ç»„
```
è¿™é‡Œçš„`list`æˆå‘˜å˜é‡, æˆ‘ä»¬å¯ä»¥ç†è§£æˆä¸ºä¸€æ®µè¿ç»­çš„å†…å­˜åœ°å€å³å¯.

```swift
    func getElement(loc index: Int) -> Element? {
        if index < 0 || index >= capacity || length == 0 {
            return nil
        }
        return list[index]
    }
    
    func locate(of element: Element) -> Int {
        for i in 0..<length {
            if list[i] == element {
                return i
            }
        }
        return -1
    }
```
æ•°ç»„æ¯”ä¹‹å‰å­¦çš„é˜Ÿåˆ—å’Œæ ˆå¤æ‚ç‚¹, æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å–å…ƒç´ å’Œå®šä½å…ƒç´ çš„å‡½æ•°çš„å®ç°, å—¯. è¿˜æ˜¯ç†è§£å°šå¯.

```swift
    func prior(of element: Element) -> Element? {
        let temp = locate(of: element)
        if temp == -1 {
            return nil
        } else {
            if temp == 0 {
                return nil
            } else {
                return list[temp - 1]
            }
        }
    }
    
    func next(of element: Element) -> Element? {
        let temp = locate(of: element)
        if temp == -1 {
            return nil
        } else {
            if temp == length - 1 {
                return nil
            } else {
                return list[temp + 1]
            }
        }
    }
```
æ¥ç€æˆ‘ä»¬æ¥çœ‹çœ‹è·å–å…ƒç´ çš„å‰åå…ƒç´ çš„å‡½æ•°, é€šè¿‡åç§»ä¸‹æ ‡æ¥è·å–å‰åå…ƒç´ , å¹¶åšäº†ç•Œé™æ§åˆ¶, æ²¡ä»€ä¹ˆå¯å¤šè¯´çš„.

```swift
    @discardableResult func insert(loc index: Int, element: Element) -> Bool {
        if index < 0 || index > length {
            return false
        }
        list.append(element)
        for i in (index..<length).reversed() {
            list[i + 1] = list[i]
        }
        list[index] = element
        length += 1
        return true
    }
    
    @discardableResult func delete(loc index: Int) -> Element? {
        if index < 0 || index >= length {
            return nil
        }
        for i in (index + 1)..<length {
            list[i - 1] = list[i]
        }
        length -= 1
        return list[index]
    }
```

æ¥è¯´è¯´æ ¸å¿ƒå‡½æ•°, æ’å…¥ä¸åˆ é™¤çš„å®ç°, å…¶å®ä¹Ÿæ˜¯é€šè¿‡åç§»æŒ‡é’ˆæ¥å®Œæˆçš„, å¯ä»¥è¯´å› ä¸ºæ•°ç»„æ˜¯ä¸€æ®µè¿ç»­çš„å†…å­˜åœ°å€, åªéœ€è¦åç§»æŒ‡é’ˆå°±å¯ä»¥å®šä½å¹¶è·å–åˆ°è¿™æ®µå†…å­˜åœ°å€ä¸­çš„ä»»æ„æ•°æ®.

```swift
        let list_i = List1<Int>(10)
        list_i.insert(loc: 0, element: 1)
        list_i.insert(loc: 1, element: 2)
        list_i.insert(loc: 2, element: 3)
        list_i.insert(loc: 3, element: 4)
        list_i.insert(loc: 4, element: 5)
        list_i.insert(loc: 5, element: 6)
        list_i.insert(loc: 6, element: 7)
        list_i.traverse() //(1, 2, 3, 4, 5, 6, 7)
        
        list_i.delete(loc: 3)
        list_i.delete(loc: 2)
        list_i.traverse() //(1, 2, 5, 6, 7)
        
        print(list_i.prior(of: 6)!) //5
        print(list_i.next(of: 1)!) //2
        print(list_i.getElement(loc: 2)!) //5
```
æˆ‘ä»¬æ¥ä½¿ç”¨ä¸€ä¸‹æ•°ç»„è¿™ä¸ªæ•°æ®ç»“æ„, å—¯, å’Œå¹³æ—¶ç”¨çš„NSArrayæ²¡æœ‰ä»€ä¹ˆå¤ªå¤§åŒºåˆ«, ä½†äº†è§£äº†å†…éƒ¨å®ç°é€»è¾‘, å¯ä»¥æ›´å¥½çš„å®šä¹‰è‡ªå·±çš„æ•°æ®ç»“æ„å¹¶è¿›è¡ŒåŠŸèƒ½çš„æ‰©å±•.

##### é“¾è¡¨

é“¾è¡¨è¿™ä¸ªæ•°æ®ç»“æ„æˆ‘åœ¨iOSå’ŒWebå¼€å‘ä¸­åŸºæœ¬æ²¡æœ‰ç”¨åˆ°è¿‡, å¯èƒ½æœ‰çš„æ•°ç»„æ¯”å¦‚NSMutableArrayæˆ–Listæ˜¯ç”¨é“¾è¡¨å®ç°çš„? è¿™ç‚¹æ²¡æœ‰éªŒè¯è¿‡ä¸èƒ½çè¯´, ä½†æˆ‘ä»¬å¯ä»¥çŸ¥é“é“¾è¡¨åœ¨æ•°æ®é‡å¤§çš„æƒ…å†µä¸‹æ€§èƒ½ä¼˜äºæ•°ç»„, æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸‹é“¾è¡¨è¿™ä¸ªæ•°æ®ç»“æ„å§.

```swift
    var data: Element? //èŠ‚ç‚¹æ•°æ®
    // for list
    var next: Node? //èŠ‚ç‚¹æŒ‡é’ˆ, æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
```
è¯´é“é“¾è¡¨, æˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªèŠ‚ç‚¹Nodeç±»æ¥å­˜å‚¨æ•°æ®å’ŒæŒ‡é’ˆ.

```swift
    private var head: Node<Element> //å¤´èŠ‚ç‚¹
    private lazy var length: Int = 0 //é“¾è¡¨é•¿åº¦
```
æœ‰äº†èŠ‚ç‚¹, æˆ‘ä»¬æ¥å®šä¹‰ä¸€ä¸‹é“¾è¡¨æ‰€éœ€è¦çš„æˆå‘˜å±æ€§å§.

```swift
    func getElement(loc index: Int) -> Node<Element>? {
        if index < 0 || index >= length {
            return nil
        }
        var currentNode = head
        for _ in 0...index {
            guard let node = currentNode.next else { continue }
            currentNode = node
        }
        let node = Node<Element>()
        node.data = currentNode.data
        return node
    }
    
    func locate(of node: Node<Element>) -> Int {
        var currentNode = head
        var count = 0
        while currentNode.next != nil {
            currentNode = currentNode.next!
            if currentNode.data == node.data {
                return count
            }
            count += 1
        }
        return -1
    }
```
ä¸æ•°ç»„çš„ä¸åŒ, é“¾è¡¨çš„è·å–åŠå®šä½å‡½æ•°, æ˜¯ä»¥èŠ‚ç‚¹æŒ‡é’ˆæŒ‡å‘è¿›è¡Œæ“ä½œçš„.

```swift
    func prior(of node: Node<Element>) -> Node<Element>? {
        var currentNode = head
        var tempNode: Node<Element>? = nil
        while currentNode.next != nil {
            tempNode = currentNode
            currentNode = currentNode.next!
            if currentNode.data == node.data {
                guard let tempNode = tempNode else { continue }
                if tempNode == head {
                    return nil
                }
                let node = Node<Element>()
                node.data = tempNode.data
                return node
            }
        }
        return nil
    }
    
    func next(of node: Node<Element>) -> Node<Element>? {
        var currentNode = head
        while currentNode.next != nil {
            currentNode = currentNode.next!
            if currentNode.data == node.data {
                if currentNode.next == nil {
                    return nil
                }
                guard let data = currentNode.next?.data else { continue }
                let node = Node<Element>()
                node.data = data
                return node
            }
        }
        return nil
    }
```
åŒç†, è·å–å‰åå…ƒç´ ä¹Ÿæ˜¯é€šè¿‡èŠ‚ç‚¹æŒ‡é’ˆè¿›è¡Œæ“ä½œçš„, ä»¥å¤´èŠ‚ç‚¹ä¸ºåŸºç‚¹, é€šè¿‡å¤šæ¬¡æŒ‡å‘æŒ‡å‘è·å–å“åº”å…ƒç´ åŠä¸‹æ ‡.

```swift
    @discardableResult func insert(loc index: Int, node: Node<Element>) -> Bool {
        if index < 0 || index >= length {
            return false
        }
        var currentNode = head
        for _ in 0..<index {
            guard let nextNode = currentNode.next else { continue }
            currentNode = nextNode
        }
        let newNode = Node<Element>()
        newNode.data = node.data
        newNode.next = currentNode.next
        currentNode.next = newNode
        length += 1
        return true
    }
    
    @discardableResult func delete(loc index: Int) -> Node<Element>? {
        if index < 0 || index >= length {
            return nil
        }
        var currentNode = head
        var currentNodeBefore: Node<Element>? = nil
        for _ in 0...index {
            currentNodeBefore = currentNode
            guard let nextNode = currentNode.next else { continue }
            currentNode = nextNode
        }
        currentNodeBefore?.next = currentNode.next
        let node = Node<Element>()
        node.data = currentNode.data
        length -= 1
        return node
    }
```
æ’å…¥å’Œåˆ é™¤çš„æ ¸å¿ƒæ“ä½œä¹Ÿæ˜¯åŒç†, é€šè¿‡`next`èŠ‚ç‚¹æŒ‡å‘å˜æ¢, è¿›è¡Œæ’å…¥å’Œåˆ é™¤.

```swift
    @discardableResult func insertHead(node: Node<Element>) -> Bool {
        let temp = head.next
        let newNode = Node<Element>()
        newNode.data = node.data
        head.next = newNode
        newNode.next = temp
        length += 1
        return true
    }
    
    @discardableResult func insertTail(node: Node<Element>) -> Bool {
        var currentNode = head
        while currentNode.next != nil {
            currentNode = currentNode.next!
        }
        let newNode = Node<Element>()
        newNode.data = node.data
        newNode.next = nil
        currentNode.next = newNode
        length += 1
        return true
    }
```
æˆ‘ä»¬è¿™é‡Œå¤šäº†ä¸€æ­¥æ’å…¥å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹çš„æ“ä½œ, å…¶å®åŸç†ä¹Ÿæ˜¯ç›¸åŒçš„, å°±æ˜¯æ”¹å˜èŠ‚ç‚¹æŒ‡é’ˆçš„æŒ‡å‘, é‡è¦çš„ä¸œè¥¿å¤šè¯´å‡ é.

```swift
        let list_i = List2<Int>()
        for i in 1...7 {
            list_i.insertTail(node: Node<Int>(data: i))
        }
        list_i.traverse() //(1, 2, 3, 4, 5, 6, 7)
        
        list_i.getElement(loc: 2)?.printNode() //3
        
        let node_i = Node<Int>(data: 1024)
        list_i.insert(loc: 5, node: node_i)
        list_i.traverse() //(1, 2, 3, 4, 5, 1024, 6, 7)
        
        print(list_i.locate(of: node_i)) //5
        print(list_i.size()) //8
        
        list_i.prior(of: node_i)?.printNode() //5
        list_i.next(of: node_i)?.printNode() //6
        list_i.delete(loc: 5)?.printNode() //1024
        
        list_i.traverse() //(1, 2, 3, 4, 5, 6, 7)
```
ä»¥ä¸Šæ˜¯é“¾è¡¨è¿™ä¸ªæ•°æ®ç»“æ„çš„ä½¿ç”¨æƒ…å†µ, å¯ä»¥æ„Ÿè§‰åˆ°FMDBå°±æ˜¯é‡‡ç”¨ç±»ä¼¼é“¾è¡¨çš„å½¢å¼å§.

#### æ ‘

äºŒå‰æ ‘, å¬çš„æŒºå¤š, åšä¸šåŠ¡å‡ ä¹ä¹Ÿæ˜¯æ²¡æœ‰ç”¨åˆ°è¿‡, æ‰€è°“äºŒå‰æ ‘, å°±æ˜¯ä»å¤´èŠ‚ç‚¹å‘ä¸‹æœ‰ä¸è¶…è¿‡ä¸¤ä¸ªçš„è‡ªå·±ç‚¹, å‘ä¸‹ä¼¸å±•å³ä¸ºäºŒå‰æ ‘, 

##### æ•°ç»„æ ‘

```swift
    private var tree: [Any] //æ ‘æ•°ç»„
    private var capacity: Int //æ ‘å®¹é‡
```
æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹æ•°ç»„æ ‘è¿™ä¸ªæ•°æ®ç»“æ„æˆ‘ä»¬éœ€è¦å“ªäº›æ•°æ®æˆå‘˜å±æ€§, 

```swift
    init(_ treeCapacity: Int, root: Element) {
        capacity = treeCapacity
        tree = [Any](repeating: 0, count: treeCapacity)
        tree[0] = root
    }
    
    func searchNode(loc index: Int) -> Element? {
        if index < 0 || index >= capacity {
            return nil
        }
        if tree[index] as? Int == 0 {
            return nil
        }
        return tree[index] as? Element
    }
```
åˆå§‹åŒ–æ„é€ æ—¶, å°†æ•°ç»„æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ ä»¥0å ä½, å¹¶å°†å¤–éƒ¨ä¼ å…¥çš„å…ƒç´ èµ‹å€¼åˆ°æ•°ç»„æ ‘çš„ç¬¬0ä¸ªä¸‹æ ‡, ä½œä¸ºæ ‘æ ¹. æœç´¢èŠ‚ç‚¹çš„ç®—æ³•å…¶å®å’Œæ•°ç»„è¿™ä¸ªæ•°æ®ç»“æ„ç›¸åŒ, é€šè¿‡ä¸‹æ ‡æ¥æŸ¥è¯¢.

```swift
    @discardableResult func addNode(loc index: Int, direction: Direction, node: Element) -> Bool {
        if index < 0 || index >= capacity {
            return false
        }
        if tree[index] as? Int == 0 {
            return false
        }
        switch direction {
        case .left:
            if index * 2 + 1 >= capacity {
                return false
            }
            if tree[index * 2 + 1] as? Int != 0 {
                return false
            }
            tree[index * 2 + 1] = node
        case .right:
            if index * 2 + 2 >= capacity {
                return false
            }
            if tree[index * 2 + 2] as? Int != 0 {
                return false
            }
            tree[index * 2 + 2] = node
        }
        return true
    }
    
    @discardableResult func deleteNode(loc index: Int) -> Bool {
        if index < 0 || index >= capacity {
            return false
        }
        if tree[index] as? Int == 0 {
            return false
        }
        tree[index] = 0
        deleteNode(loc: index * 2 + 1)
        deleteNode(loc: index * 2 + 2)
        return true
    }
```
æ·»åŠ åŠåˆ é™¤èŠ‚ç‚¹, æ·»åŠ çš„æ—¶å€™ç”¨äº†ä¸€ä¸ªç®€å•çš„æ•°å­¦å…¬å¼, å› ä¸ºæ˜¯äºŒå‰æ ‘æ‰€ä»¥`index * 2`, å·¦è¾¹å­èŠ‚ç‚¹ä¸º `+1`, å³è¾¹å­èŠ‚ç‚¹ä¸º`+2`. åˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™ä½¿ç”¨äº†é€’å½’, ä¹ŸåŒæ ·ä½¿ç”¨äº†è¿™ä¸ªå…¬å¼.

```swift
        let tree_i = Tree1(15, root: Node<Int>(data: 3))
        tree_i.addNode(loc: 0, direction: .right, node: Node<Int>(data: 4))
        tree_i.addNode(loc: 2, direction: .left, node: Node<Int>(data: 5))
        tree_i.addNode(loc: 5, direction: .right, node: Node<Int>(data: 6))
        
        tree_i.traverse() //(304005000000600)
        
        tree_i.searchNode(loc: 5)?.printNode() //5
        tree_i.deleteNode(loc: 2)
        
        tree_i.traverse() //(300000000000000)
        
```
å¯ä»¥çœ‹åˆ°æ•°ç»„æ ‘å°±æ˜¯ä»¥ç¬¬ä¸€ä¸ªä¸‹æ ‡ä½œä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹, åé¢çš„ä»¥0å ä½, å¦‚æœæ˜¯å­èŠ‚ç‚¹, åˆ™æ˜¾ç¤ºå­èŠ‚ç‚¹çš„æ•°æ®, æ²¡æœ‰å­èŠ‚ç‚¹å°±æ˜¯0.

##### é“¾è¡¨æ ‘

å­¦ä¼šäº†æ•°ç»„æ ‘, æˆ‘ä»¬æ¥çœ‹çœ‹é“¾è¡¨æ ‘åˆ°åº•æ˜¯ä¸€ä¸ªæ€ä¹ˆä¼šäº‹, å¯èƒ½æƒ³è±¡ä¹Ÿå°±çŸ¥é“, æ˜¯é€šè¿‡é“¾è¡¨çš„å½¢å¼è¿›è¡Œæ ‘çš„å»¶ä¼¸, è€Œä¸æ˜¯ä»¥0å ä½å§. çœ‹çœ‹æ˜¯ä»€ä¹ˆæ­Œæƒ…å†µå§.

```swift
    // for tree
    var index: Int = 0
    var leftChild: Node?
    var rightChild: Node?
    var parent: Node?
```

é¦–å…ˆ, æˆ‘ä»¬å…ˆåœ¨æ ‘çš„èŠ‚ç‚¹ä¸Šå®šä¹‰ä¸€ä¸‹æ‰€éœ€è¦çš„å…ƒç´ , å’Œä¹‹å‰é“¾è¡¨çš„èŠ‚ç‚¹ç±»ä¼¼, åªæ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜æˆäº†ä¸‰ä¸ª.

```swift
    func searchNode(nodeIndex: Int) -> Node<Element>? {
        if index == nodeIndex {
            return self
        }
        var temp: Node<Element>? = nil
        if leftChild != nil {
            if leftChild?.index == nodeIndex {
                return leftChild
            } else {
                temp = leftChild?.searchNode(nodeIndex: nodeIndex)
                if temp != nil {
                    return temp
                }
            }
        }
        if rightChild != nil {
            if rightChild?.index == nodeIndex {
                return rightChild
            } else {
                temp = rightChild?.searchNode(nodeIndex: nodeIndex)
                if temp != nil {
                    return temp
                }
            }
        }
        return nil
    }
```

è¿˜éœ€è¦åœ¨èŠ‚ç‚¹ä¸­æ·»åŠ æœç´¢èŠ‚ç‚¹çš„æ–¹æ³•, å› ä¸ºæ˜¯é“¾è¡¨, æ‰€ä»¥èŠ‚ç‚¹è‡ªèº«ä¹Ÿæˆä¸ºäº†é“¾è¡¨çš„ä¸€éƒ¨åˆ†, æ‰€ä»¥æœç´¢çš„é€»è¾‘å†™å…¥åœ¨èŠ‚ç‚¹ä¸­æ˜¯éå¸¸åˆé€‚çš„.

```swift
    func deleteNode() {
        if leftChild != nil {
            leftChild?.deleteNode()
        }
        if rightChild != nil {
            rightChild?.deleteNode()
        }
        if parent != nil {
            if parent?.leftChild == self {
                parent?.leftChild = nil
            }
            if parent?.rightChild == self {
                parent?.rightChild = nil
            }
        }
        parent = nil
    }
```
è¿˜éœ€è¦æ·»åŠ åˆ é™¤èŠ‚ç‚¹çš„å‡½æ•°åœ¨èŠ‚ç‚¹ä¸­è¿›è¡Œé€’å½’.

```swift
    enum PrintType {
        case dafault
        case preorder
        case inorder
        case postorder
    }
    
    func printNode(_ type: PrintType = .dafault) {
        guard let data = data else { return }
        switch type {
        case .dafault:
            print(data)
        case .preorder:
            print("\(index), \(data)")
            if leftChild != nil {
                leftChild?.printNode(.preorder)
            }
            if rightChild != nil {
                rightChild?.printNode(.preorder)
            }
        case .inorder:
            if leftChild != nil {
                leftChild?.printNode(.inorder)
            }
            print("\(index), \(data)")
            if rightChild != nil {
                rightChild?.printNode(.inorder)
            }
        case .postorder:
            if leftChild != nil {
                leftChild?.printNode(.postorder)
            }
            if rightChild != nil {
                rightChild?.printNode(.postorder)
            }
            print("\(index), \(data)")
        }
    }
```
èŠ‚ç‚¹ä¸­, æˆ‘ä»¬æœ€åéœ€è¦åŠ å…¥æ‰“å°èŠ‚ç‚¹çš„æ–¹æ³•, è¿™é‡Œé€šè¿‡æšä¸¾åˆ¤æ–­æ˜¯å‰åºéå†, ä¸­åºéå†è¿˜æ˜¯ååºéå†.

```swift
    private var root: Node<Element> //å¤´èŠ‚ç‚¹
    
    init(root node: Node<Element>) {
        root = node
    }
    
    func searchNode(loc index: Int) -> Node<Element>? {
        return root.searchNode(nodeIndex: index)
    }
```
æœ‰äº†åˆšæ‰çš„èŠ‚ç‚¹æ”¯æŒ, æˆ‘ä»¬åœ¨é“¾è¡¨æ ‘ä¸­çš„æ“ä½œå°±è½»æ¾å¤šäº†, åªéœ€è¦å¯¼å…¥ä¸€ä¸ªå¤´èŠ‚ç‚¹, æœç´¢èŠ‚ç‚¹ä¹Ÿåªéœ€è¦è°ƒç”¨åˆšæ‰èŠ‚ç‚¹ä¸­çš„é¥¿æœç´¢æ–¹æ³•.

```swift
    func preorderTraversal() {
        print("ï¸µ")
        root.printNode(.preorder)
        print("ï¸¶")
    }
    
    func inorderTraversal() {
        print("ï¸µ")
        root.printNode(.inorder)
        print("ï¸¶")
    }
    
    func postorderTraversal() {
        print("ï¸µ")
        root.printNode(.postorder)
        print("ï¸¶")
    }
```
å‰åºéå†, ååºéå†, ä¸­åºéå†åªéœ€è¦ä¼ å…¥ä¸åŒçš„æšä¸¾å³å¯, é€»è¾‘éƒ½åœ¨åˆšæ‰çš„èŠ‚ç‚¹å‡½æ•°ä¸­å®ç°äº†.

```swift
    @discardableResult  func addNode(loc index: Int, direction: Direction, node: Node<Element>) -> Bool {
        guard let temp = searchNode(loc: index) else { return false }
        let newNode = Node<Element>()
        newNode.index = node.index
        newNode.data = node.data
        newNode.parent = temp
        if direction == .left {
            temp.leftChild = newNode
        }
        if direction == .right {
            temp.rightChild = newNode
        }
        return true
    }
    
    @discardableResult func deleteNode(loc index: Int) -> Node<Element>? {
        guard let temp = searchNode(loc: index) else { return nil }
        temp.deleteNode()
        return temp
    }
```
åˆ é™¤èŠ‚ç‚¹ä¹Ÿæ˜¯è°ƒç”¨äº†èŠ‚ç‚¹ä¸­çš„é€’å½’æ–¹æ³•, å€¼å¾—æ³¨æ„çš„åªæœ‰æ·»åŠ èŠ‚ç‚¹çš„æ–¹æ³•, æˆ‘ä»¬å¯ä»¥çœ‹åˆ°, æ·»åŠ èŠ‚ç‚¹åšçš„å°±æ˜¯åƒå­èŠ‚ç‚¹æŒ‡é’ˆè¿›è¡Œèµ‹å€¼, å¹¶é€šè¿‡æœç´¢æ–¹æ³•å®šä½åˆ°è¯¥èµ‹å€¼çš„èŠ‚ç‚¹.

```swift
let tree_i = Tree2(root: Node<Int>(data: 0))
tree_i.addNode(loc: 0, direction: .right, node: Node<Int>(index: 1, data: 4))
tree_i.addNode(loc: 1, direction: .left, node: Node<Int>(index: 2, data: 5))
tree_i.addNode(loc: 2, direction: .right, node: Node<Int>(index: 3, data: 6))
        
tree_i.preorderTraversal()
tree_i.inorderTraversal()
tree_i.postorderTraversal()
        
/*
ï¸µ
0, 0
1, 4
2, 5
3, 6
ï¸¶
ï¸µ
0, 0
2, 5
3, 6
1, 4
ï¸¶
ï¸µ
3, 6
2, 5
1, 4
0, 0
ï¸¶
*/
        
tree_i.searchNode(loc: 3)?.printNode() //6
tree_i.deleteNode(loc: 1)
        
tree_i.preorderTraversal() //(0,0)
tree_i.inorderTraversal() //(0,0)
tree_i.postorderTraversal() //(0,0)
```

é“¾è¡¨æ ‘å’Œæ•°ç»„æ ‘çš„ä½¿ç”¨ä¹Ÿæ˜¯å¦‚å‡ºä¸€è¾™, å°±å’Œæ•°ç»„å’Œé“¾è¡¨çš„å…³ç³»ä¸€æ ·, ä¸€ä¸ªæ˜¯ä¸‹æ ‡ç´¢å¼•, ä¸€ä¸ªæ˜¯æŒ‡é’ˆæŒ‡å‘.

#### å›¾

ç»ˆäºè¦è®²åˆ°æœ€ä¸ºå…³é”®çš„ä¸€ä¸ªæ•°æ®ç»“æ„äº†, å›¾, åˆšå­¦ä¹ çš„æ—¶å€™å¯¹äºå›¾çœŸçš„æœ‰ç‚¹ä¸å¥½ç†è§£, ä»€ä¹ˆæ˜¯å›¾, å—¯.... ä¸å¥½æè¿°. ä¸å¥½æè¿°å°±ç”¨ç”»çš„å§.

![](http://upload-images.jianshu.io/upload_images/1229762-bff946b3d80a3711.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

ä¸Šé¢çš„è½¨é“äº¤é€šå›¾, å°±æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„ä¸€ä¸ªæ— å‘å›¾, å¯ä»¥è¯´æ˜¯å›¾è¿™ä¸ªæ•°æ®ç»“æ„çš„å®Œç¾å†™ç…§, æ¯”å¦‚è¯´è¦ä»é™å®‰å¯ºåˆ°é™†å®¶å˜´å†åˆ°äººæ°‘å¹¿åœºå†åˆ°å¾å®¶æ±‡å†åˆ°ä¸–çºªå¤§é“çš„æœ€è¿‘è·ç¦», å°±æ˜¯æœ€å°ç”Ÿæˆæ ‘ç®—æ³•. ç®—æ³•æˆ‘ä»¬ç­‰ä¼šè¯´, æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å›¾è¿™ä¸ªæ•°æ®ç»“æ„.

```swift
    // for map
    var visited: Bool = false //æ˜¯å¦è®¿é—®
```
æˆ‘ä»¬éœ€è¦åœ¨èŠ‚ç‚¹ä¸­æ·»åŠ æ˜¯å¦è®¿é—®çš„å­—æ®µ

```swift
    class Edge {
        var nodeIndexA: Int //ç‚¹A
        var nodeIndexB: Int //ç‚¹B
        var weightValue: Int //è¾¹çš„æƒé‡
        var selected: Bool = false //æ˜¯å¦é€‰æ‹©æ­¤è¾¹
        
        init(nodeIndexA A: Int = 0, nodeIndexB B: Int = 0, weightValue Val: Int = 0) {
            nodeIndexA = A
            nodeIndexB = B
            weightValue = Val
        }
    }
```
è¿˜éœ€è¦åˆ›å»ºä¸€ä¸ªè¾¹çš„ç±», å¹¶å£°æ˜ä»¥ä¸Šæˆå‘˜å±æ€§.

```
    private var capacity: Int //å›¾çš„å®¹é‡
    private var matrix: [Int] //å›¾çš„çŸ©é˜µ
    private var edge: [Edge] //è¾¹çš„é›†åˆ
    private lazy var count: Int = 0 //å›¾çš„æ•°é‡
    private lazy var map: [Node<Element>] = [Node<Element>]() //å›¾é›†åˆ
    
    init(_ mapCapacity: Int) {
        capacity = mapCapacity
        matrix = [Int](repeating: 0, count: capacity * capacity)
        edge = [Edge](repeating: Edge(), count: capacity - 1)
    }
```
å®šä¹‰ä¸Šè¿°æˆå‘˜å±æ€§, å¹¶è¿›è¡Œåˆå§‹åŒ–.

```swift
    @discardableResult func addNode(_ node: Node<Element>?) -> Bool {
        guard let node = node else { return false }
        map.append(node)
        map[count].data = node.data
        count += 1
        return true
    }
    
    func resetNode() {
        for i in 0..<count {
            map[i].visited = false
        }
    }
```
æ·»åŠ èŠ‚ç‚¹å’Œé‡ç½®èŠ‚ç‚¹çš„å‡½æ•°, æ²¡ä»€ä¹ˆå¥½è¯´, è¯·å›é¡¾æ•°ç»„ç¯‡.

```swift
    @discardableResult func setValueToMatrixForDirectedGraph(row: Int, col: Int, val: Int = 1) -> Bool {
        if row < 0 || row >= capacity {
            return false
        }
        if col < 0 || col >= capacity {
            return false
        }
        matrix[row * capacity + col] = val
        return true
    }
    
    @discardableResult func setValueToMatrixForUndirectedGraph(row: Int, col: Int, val: Int = 1) -> Bool {
        if row < 0 || row >= capacity {
            return false
        }
        if col < 0 || col >= capacity {
            return false
        }
        matrix[row * capacity + col] = val
        matrix[col * capacity + row] = val
        return true
    }
```
å•è¾¹å›¾å’Œæ— å‘å›¾çš„åŒºåˆ«, å³æ˜¯çŸ©é˜µä¸­çš„å±•ç¤ºåŒºåˆ«.

```swift
    func depthFirstTraverse(loc index: Int) {
        print("ï¸µ")
        func depthFirstTraverseImpl(loc index: Int) {
            guard let data = map[index].data else { return }
            print(data)
            map[index].visited = true
            for i in 0..<capacity {
                let value = getValueFromMatrix(row: index, col: i)
                if value == 1 {
                    if map[i].visited {
                        continue
                    } else {
                        depthFirstTraverseImpl(loc: i)
                    }
                } else {
                    continue
                }
            }
        }
        depthFirstTraverseImpl(loc: index)
        print("ï¸¶")
    }
```
æ·±åº¦ä¼˜å…ˆéå†, å°±æ˜¯çºµå‘çš„ç»“æ„è¿›è¡Œéå†.

```swift
    func breadthFirstTraverse(loc index: Int) {
        print("ï¸µ")
        guard let data = map[index].data else { return }
        print(data)
        map[index].visited = true
        var temp = [Int]()
        temp.append(index)
        func breadthFirstTraverseImpl(preTemp: [Int]) {
            var temp = [Int]()
            for i in 0..<preTemp.count {
                for j in 0..<capacity {
                    let value = getValueFromMatrix(row: preTemp[i], col: j)
                    if value != 0 {
                        if map[j].visited {
                            continue
                        } else {
                            guard let data = map[j].data else { return }
                            print(data)
                            map[j].visited = true
                            temp.append(j)
                        }
                    }
                }
            }
            if temp.count == 0 {
                return
            } else {
                breadthFirstTraverseImpl(preTemp: temp)
            }
        }
        breadthFirstTraverseImpl(preTemp: temp)
        print("ï¸¶")
    }
```
å¹¿åº¦ä¼˜å…ˆéå†, å°±æ˜¯ä¸€å±‚å±‚çš„è¿›è¡Œéå†, å…ˆå¾—åˆ°ç¬¬ä¸€å±‚çš„æ ¹èŠ‚ç‚¹, å†ç¬¬äºŒå±‚, ç¬¬ä¸‰å±‚, ä»¥æ­¤ç±»æ¨.

```swift
    private func getValueFromMatrix(row: Int, col: Int) -> Int? {
        if row < 0 || row >= capacity {
            return nil
        }
        if col < 0 || col >= capacity {
            return nil
        }
        return matrix[row * capacity + col]
    }
```
ä»çŸ©é˜µä¸­è·å–å€¼çš„å‡½æ•°, å—¯... åšäº†è¾¹ç•Œæ§åˆ¶.

##### æœ€å°ç”Ÿæˆæ ‘ç®—æ³•

```
    func primTree(loc index: Int) {
        var edgeCount = 0
        var edgeBuffers = [Edge]()
        var nodeIndexes = [Int]()
        var primTreePath = [Element]()
        
        nodeIndexes.append(index)
        map[index].visited = true
        primTreePath.append(map[index].data!)
        
        while edgeCount < capacity - 1 {
            guard let index: Int = nodeIndexes.last else { continue }
            for i in 0..<capacity {
                guard let value = getValueFromMatrix(row: index, col: i) else { continue }
                if value != 0 {
                    if map[i].visited {
                        continue
                    } else {
                        edgeBuffers.append(Edge(nodeIndexA: index, nodeIndexB: i, weightValue: value))
                    }
                }
            }
            
            let edgeIndex = getMinEdge(buffers: edgeBuffers)
            edgeBuffers[edgeIndex].selected = true
            
            print(edgeBuffers[edgeIndex].nodeIndexA, edgeBuffers[edgeIndex].nodeIndexB, edgeBuffers[edgeIndex].weightValue)
            
            edge[edgeCount] = edgeBuffers[edgeIndex]
            edgeCount += 1
            
            let nextNodeIndex = edgeBuffers[edgeIndex].nodeIndexB
            nodeIndexes.append(nextNodeIndex)
            map[nextNodeIndex].visited = true
            
            primTreePath.append(map[nextNodeIndex].data!)
        }
        for node in primTreePath {
            print("\(node)", terminator: "")
        }
        print()
    }

```
primç®—æ³•, æ ¸å¿ƒæ€æƒ³æ˜¯è·å–æ‰€æœ‰çš„è¾¹æ”¾å…¥å¾…é€‰è¾¹é›†åˆ, å¹¶æ ¹æ®æ‰€æœ‰çš„è¾¹çš„æƒé‡è·å–æœ€å°æƒé‡çš„è¾¹æ”¾å…¥è¾¹é›†åˆ, è¿™æ­¥éœ€è¦åˆ¤æ–­æ˜¯éƒ½ç‚¹æ˜¯å¦è®¿é—®è¿‡.å¦‚æ­¤å¾€å¤å°±å¯ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘.

```swift
    func kruskalTree() {
        var edgeCount = 0
        var edgeBuffers = [Edge]()
        var nodeIndexes = [[Int]]()
        for i in 0..<capacity {
            for j in i + 1..<capacity {
                guard let value = getValueFromMatrix(row: i, col: j) else { continue }
                if value != 0 {
                    edgeBuffers.append(Edge(nodeIndexA: i, nodeIndexB: j, weightValue: value))
                }
            }
        }
        while edgeCount < capacity - 1 {
            let minEdgeIndex = getMinEdge(buffers: edgeBuffers)
            edgeBuffers[minEdgeIndex].selected = true
            let nodeAIndex = edgeBuffers[minEdgeIndex].nodeIndexA
            let nodeBIndex = edgeBuffers[minEdgeIndex].nodeIndexB
            var nodeAIsInSet = false
            var nodeBIsInSet = false
            var nodeAInSetLabel = -1
            var nodeBInSetLabel = -1
            for i in 0..<nodeIndexes.count {
                nodeAIsInSet = isInSet(nodeIndexes[i], nodeAIndex)
                if nodeAIsInSet {
                    nodeAInSetLabel = i
                }
            }
            for i in 0..<nodeIndexes.count {
                nodeBIsInSet = isInSet(nodeIndexes[i], nodeBIndex)
                if nodeBIsInSet {
                    nodeBInSetLabel = i
                }
            }
            if nodeAInSetLabel == -1 && nodeBInSetLabel == -1 {
                var vec = [Int]()
                vec.append(nodeAIndex)
                vec.append(nodeBIndex)
                nodeIndexes.append(vec)
            } else if nodeAInSetLabel == -1 && nodeAInSetLabel != -1 {
                nodeIndexes[nodeBInSetLabel].append(nodeAIndex)
            } else if nodeAInSetLabel != -1 && nodeAInSetLabel == -1 {
                nodeIndexes[nodeAInSetLabel].append(nodeBIndex)
            } else if nodeAInSetLabel != -1 && nodeBInSetLabel != -1 && nodeAInSetLabel != nodeBInSetLabel {
                nodeIndexes[nodeAInSetLabel] =
                    mergeNodeSets(nodeIndexes[nodeAInSetLabel], nodeIndexes[nodeBInSetLabel])
                for i in nodeBInSetLabel..<nodeIndexes.count-1 {
                    nodeIndexes[i] = nodeIndexes[i + 1]
                }
            } else if nodeAInSetLabel != -1 && nodeBInSetLabel != -1 && nodeAInSetLabel == nodeBInSetLabel {
                continue
            }
            edge[edgeCount] = edgeBuffers[minEdgeIndex]
            edgeCount += 1
            print(edgeBuffers[minEdgeIndex].nodeIndexA, edgeBuffers[minEdgeIndex].nodeIndexB, edgeBuffers[minEdgeIndex].weightValue)
        }
    }
    
    private func getMinEdge(buffers edgeBuffers: [Edge]) -> Int {
        var minWeight = 0
        var edgeIndex = 0
        var i = 0
        for _ in 0..<edgeBuffers.count {
            if !edgeBuffers[i].selected {
                minWeight = edgeBuffers[i].weightValue
                edgeIndex = i
                break
            }
            i += 1
        }
        if minWeight == 0 {
            return -1;
        }

        for _ in i..<edgeBuffers.count {
            if edgeBuffers[i].selected {
                i += 1
                continue
            } else {
                if minWeight > edgeBuffers[i].weightValue {
                    minWeight = edgeBuffers[i].weightValue
                    edgeIndex = i
                }
            }
            i += 1
        }
        return edgeIndex
    }
    
    private func isInSet(_ nodeSet:[Int], _ target: Int) -> Bool {
        for i in 0..<nodeSet.count {
            if nodeSet[i] == target {
                return true
            }
        }
        return false
    }
    
    private func mergeNodeSets(_ nodeSetA: [Int], _ nodeSetB: [Int]) -> [Int] {
        var nodeSet = [Int]()
        for i in 0..<nodeSetB.count {
            nodeSet.append(nodeSetB[i])
        }
        return nodeSet
    }

```
kruskalç®—æ³•å°±æ¯”è¾ƒå¤æ‚äº†, é¦–å…ˆæˆ‘ä»¬è¦å°†æ‰€æœ‰è¾¹æ”¾å…¥å¾…é€‰è¾¹é›†åˆä¸­, ç„¶ååœ¨æ‰€æœ‰è¾¹ä¸­é€‰å‡ºä¸€æ¡æƒå€¼æœ€å°çš„è¾¹æ”¾å…¥å·²é€‰è¾¹é›†åˆä¸­, æˆ‘ä»¬é€‰å®šäº†è¾¹å°±é€‰å®šäº†ç‚¹å¹¶æ”¾å…¥å·²é€‰ç‚¹é›†åˆ, å¦‚æ­¤å¾€å¤, é€‰æ‹©æ¬¡å°çš„è¾¹å¹¶è·å–è¾¹å’Œç‚¹, é‡ç‚¹æ˜¯éœ€è¦åˆ¤æ–­æ˜¯å¦å’Œä¹‹å‰å·²é€‰çš„è¾¹å½¢æˆé—­ç¯, å¦‚æœå½¢æˆé—­ç¯åˆ™éœ€è¦æŠ›å¼ƒ.éœ€è¦æ¶‰åŠæ‰€æœ‰çš„ç‚¹, å¹¶åˆæˆä¸€ä¸ªç‚¹æ•°ç»„æ‰ç®—å®Œæˆ.

```swift
    let map_s = Map<String>(8)
    map_s.addNode(Node<String>(data: "A"))
    map_s.addNode(Node<String>(data: "B"))
    map_s.addNode(Node<String>(data: "C"))
    map_s.addNode(Node<String>(data: "D"))
    map_s.addNode(Node<String>(data: "E"))
    map_s.addNode(Node<String>(data: "F"))
    map_s.addNode(Node<String>(data: "G"))
    map_s.addNode(Node<String>(data: "H"))
    
    map_s.setValueToMatrixForUndirectedGraph(row: 0, col: 1)
    map_s.setValueToMatrixForUndirectedGraph(row: 0, col: 3)
    map_s.setValueToMatrixForUndirectedGraph(row: 1, col: 2)
    map_s.setValueToMatrixForUndirectedGraph(row: 1, col: 5)
    map_s.setValueToMatrixForUndirectedGraph(row: 3, col: 6)
    map_s.setValueToMatrixForUndirectedGraph(row: 3, col: 7)
    map_s.setValueToMatrixForUndirectedGraph(row: 6, col: 7)
    map_s.setValueToMatrixForUndirectedGraph(row: 2, col: 4)
    map_s.setValueToMatrixForUndirectedGraph(row: 4, col: 5)

    map_s.printMatrix()
    /*
	ï¸µ
	0 1 0 1 0 0 0 0 
	1 0 1 0 0 1 0 0 
	0 1 0 0 1 0 0 0 
	1 0 0 0 0 0 1 1 
	0 0 1 0 0 1 0 0 
	0 1 0 0 1 0 0 0 
	0 0 0 1 0 0 0 1 
	0 0 0 1 0 0 1 0 
	ï¸¶
	*/
    map_s.depthFirstTraverse(loc: 0) //(ABEFDGH)
    map_s.resetNode()
    map_s.breadthFirstTraverse(loc: 0) //(ABDCFGHE)

```
æœ€åæˆ‘ä»¬æ¥ä½¿ç”¨ä¸‹å›¾è¿™ä¸ªæ•°æ®ç»“æ„, å¯ä»¥çœ‹åˆ°å›¾è¿™ä¸ªæ•°æ®ç»“æ„è¿˜æ˜¯å’Œä¹‹å‰æ‰€å­¦æŒºä¸ä¸€æ ·çš„. çœ‹åˆ°äº†çŸ©é˜µå’Œæ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆçš„å·®å¼‚.

```swift
    let map = Map<String>(6)
    map.addNode(Node<String>(data: "A"))
    map.addNode(Node<String>(data: "B"))
    map.addNode(Node<String>(data: "C"))
    map.addNode(Node<String>(data: "D"))
    map.addNode(Node<String>(data: "E"))
    map.addNode(Node<String>(data: "F"))
        
    map.setValueToMatrixForUndirectedGraph(row: 0, col: 1, val: 6)
    map.setValueToMatrixForUndirectedGraph(row: 0, col: 4, val: 5)
    map.setValueToMatrixForUndirectedGraph(row: 0, col: 5, val: 1)
    map.setValueToMatrixForUndirectedGraph(row: 1, col: 2, val: 3)
    map.setValueToMatrixForUndirectedGraph(row: 1, col: 5, val: 2)
    map.setValueToMatrixForUndirectedGraph(row: 2, col: 5, val: 8)
    map.setValueToMatrixForUndirectedGraph(row: 2, col: 3, val: 7)
    map.setValueToMatrixForUndirectedGraph(row: 3, col: 5, val: 4)
    map.setValueToMatrixForUndirectedGraph(row: 3, col: 4, val: 2)
    map.setValueToMatrixForUndirectedGraph(row: 4, col: 5, val: 9)
        
    map.printMatrix()
    /*
    ï¸µ
    0 6 0 0 5 1 
    6 0 3 0 0 2 
    0 3 0 7 0 8 
    0 0 7 0 2 4 
    5 0 0 2 0 9 
    1 2 8 4 9 0 
    ï¸¶
    */
    map.primTree(loc: 0)
    /*
    0 5 1
    5 1 2
    1 2 3
    5 3 4
    3 4 2
    AFBCDE
    */
    map.kruskalTree()
    /*
    0 5 1
    1 5 2
    3 4 2
    1 2 3
    3 5 4
    */

```

æ¥ç€æˆ‘ä»¬æ¥çœ‹çœ‹æœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•, å¯ä»¥çœ‹åˆ°ä¸ç®¡æ˜¯é‚£ç§ç®—æ³•, éƒ½èƒ½å¤Ÿå°†æœ€å°ç”Ÿæˆæ ‘ç»™ç®—å‡ºæ¥, ç®—æ³•çœŸæ˜¯åšå¤§ç²¾æ·±å•Š.

æ•°æ®ç»“æ„å…³é”®æ˜¯å¤šç»ƒå¤šæ€è€ƒ, æœ‰äº†å¥½çš„ç®—æ³•æ€ç»´, æ‰èƒ½å¤Ÿå¯¹ä»¥åçš„æˆé•¿æœ‰æ‰€å¸®åŠ©!!


![ç‚¹å‡»ä¸‹æ–¹é“¾æ¥è·³è½¬!!](http://upload-images.jianshu.io/upload_images/1229762-3f8925783027b3fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 [ğŸŒŸæºç  è¯·ç‚¹è¿™é‡ŒğŸŒŸ >>> å–œæ¬¢çš„æœ‹å‹è¯·ç‚¹å–œæ¬¢ >>> ä¸‹è½½æºç çš„åŒå­¦è¯·é€ä¸‹å°æ˜Ÿæ˜Ÿ >>> æœ‰é—²é’±çš„å£•ä»¬å¯ä»¥è¿›è¡Œæ‰“èµ >>> å°å¼Ÿä¼šå°½å¿«æ¨å‡ºæ›´å¥½çš„æ–‡ç« å’Œå¤§å®¶åˆ†äº« >>> ä½ çš„æ¿€åŠ±å°±æ˜¯æˆ‘çš„åŠ¨åŠ›!! ](https://github.com/coderZsq/coderZsq.target.swift)